---
/**
 * BlogPost Layout
 * UX Psychology Principles Applied:
 * - Goal Gradient Effect: Reading progress bar shows completion and motivates readers
 * - Peak-End Rule: Celebration at 100% creates positive memory
 * - Cognitive Load Reduction: Clear visual hierarchy and readable typography
 */
import { Image } from 'astro:assets';
import type { CollectionEntry } from 'astro:content';
import BaseHead from '../components/BaseHead.astro';
import AuthorBox from '../components/AuthorBox.astro';
import BuyMeACoffee from '../components/BuyMeACoffee.astro';
import BlogPostLanguageSwitcher from '../components/BlogPostLanguageSwitcher.astro';
import Footer from '../components/Footer.astro';
import FormattedDate from '../components/FormattedDate.astro';
import Header from '../components/Header.astro';
import ReadingProgress from '../components/ReadingProgress.astro';
import { useTranslations, type Language } from '../lib/i18n/languages';
import { SITE_TITLE } from '../consts';
import RelatedPosts from '../components/RelatedPosts.astro';

type Props = CollectionEntry<'blog'>['data'] & {
	lang: Language;
	tags?: string[];
	postId?: string;
	relatedPosts?: Array<{
		slug: string;
		score: number;
		reason: { ko: string; ja: string; en: string; zh: string };
	}>;
};

const { title, description, pubDate, updatedDate, heroImage, lang, tags, postId, relatedPosts } = Astro.props;
const t = useTranslations(lang);

// Extract slug from URL pathname (e.g., /ko/blog/ko/post-title -> post-title)
const slug = Astro.url.pathname.split('/').filter(Boolean).pop() || '';

// BreadcrumbList Schema
const breadcrumbSchema = {
	'@context': 'https://schema.org',
	'@type': 'BreadcrumbList',
	'itemListElement': [
		{
			'@type': 'ListItem',
			'position': 1,
			'name': t('nav.home'),
			'item': new URL(`/${lang}`, Astro.site).toString(),
		},
		{
			'@type': 'ListItem',
			'position': 2,
			'name': t('nav.blog'),
			'item': new URL(`/${lang}/blog`, Astro.site).toString(),
		},
		{
			'@type': 'ListItem',
			'position': 3,
			'name': title,
			'item': Astro.url.toString(),
		},
	],
};
---

<html lang={lang}>
	<head>
		<BaseHead
			title={title}
			description={description}
			image={heroImage}
			articleData={{
				publishedTime: pubDate.toISOString(),
				modifiedTime: updatedDate?.toISOString(),
				author: SITE_TITLE,
				tags: tags,
			}}
		/>
		<!-- BreadcrumbList Schema -->
		<script type="application/ld+json" set:html={JSON.stringify(breadcrumbSchema)} />
	</head>

	<body class="bg-gray-50 dark:bg-gray-900">
		<!-- UX: Reading Progress Bar (Goal Gradient Effect - motivation increases as users approach completion) -->
		<ReadingProgress showCelebration={true} />
		<Header lang={lang} />
		<main class="py-12">
			<article class="max-w-4xl mx-auto px-0 sm:px-6 lg:px-8">
				{heroImage && (
					<div class="mb-8 -mx-4 sm:mx-0">
						<Image
							width={1020}
							height={510}
							src={heroImage}
							alt={title}
							class="w-full h-auto rounded-none sm:rounded-2xl shadow-xl object-cover"
							loading="eager"
							fetchpriority="high"
							format="webp"
							quality={85}
						/>
					</div>
				)}

				<div class="bg-white dark:bg-gray-800 rounded-2xl shadow-sm p-4 sm:p-8 lg:p-12">
					<!-- Header -->
					<header class="mb-6 sm:mb-8 pb-6 sm:pb-8 border-b border-gray-200 dark:border-gray-700">
						<div class="flex items-center gap-2 text-xs sm:text-sm text-gray-500 dark:text-gray-400 mb-3 sm:mb-4">
							<time datetime={pubDate.toISOString()}>
								{t('blog.publishedOn')}: <FormattedDate date={pubDate} />
							</time>
							{updatedDate && (
								<>
									<span>•</span>
									<time datetime={updatedDate.toISOString()} class="italic">
										{t('blog.updatedOn')}: <FormattedDate date={updatedDate} />
									</time>
								</>
							)}
						</div>
						<h1 class="text-2xl sm:text-4xl lg:text-5xl font-bold text-gray-900 dark:text-gray-100 mb-3 sm:mb-4 leading-tight">
							{title}
						</h1>
						<p class="text-base sm:text-lg lg:text-xl text-gray-600 dark:text-gray-300">
							{description}
						</p>
					</header>

					<!-- Content -->
					<div class="prose sm:prose-lg prose-gray max-w-none
						prose-headings:font-bold prose-headings:text-gray-900 dark:prose-headings:text-gray-100
						prose-h2:text-xl sm:prose-h2:text-2xl lg:prose-h2:text-3xl prose-h2:mt-8 sm:prose-h2:mt-12 prose-h2:mb-4 sm:prose-h2:mb-6
						prose-h3:text-lg sm:prose-h3:text-xl lg:prose-h3:text-2xl prose-h3:mt-6 sm:prose-h3:mt-8 prose-h3:mb-3 sm:prose-h3:mb-4
						prose-p:text-gray-700 dark:prose-p:text-gray-300 prose-p:leading-relaxed prose-p:text-sm sm:prose-p:text-base
						prose-a:text-accent prose-a:no-underline hover:prose-a:underline
						prose-strong:text-gray-900 dark:prose-strong:text-gray-100 prose-strong:font-semibold
						prose-code:text-accent prose-code:bg-gray-100 dark:prose-code:bg-gray-700 dark:prose-code:text-gray-100 prose-code:px-1.5 prose-code:py-0.5 prose-code:rounded prose-code:font-mono prose-code:text-xs sm:prose-code:text-sm prose-code:before:content-none prose-code:after:content-none
						prose-pre:bg-gray-900 dark:prose-pre:bg-gray-800 prose-pre:text-gray-100 prose-pre:text-xs sm:prose-pre:text-sm
						prose-blockquote:border-accent prose-blockquote:bg-accent/5 dark:prose-blockquote:bg-accent/10 prose-blockquote:py-2
						prose-img:rounded-lg prose-img:shadow-md
						prose-ul:text-sm sm:prose-ul:text-base
						prose-ol:text-sm sm:prose-ol:text-base
						prose-li:text-sm sm:prose-li:text-base dark:prose-li:text-gray-300
					">
						<slot />
					</div>

					<!-- Language Switcher -->
					<BlogPostLanguageSwitcher slug={slug} currentLang={lang} />

					<!-- Buy Me a Coffee -->
					<BuyMeACoffee lang={lang} />

					<!-- Author Box -->
					<AuthorBox lang={lang} />

					<!-- Related Posts (V3) -->
					{relatedPosts && relatedPosts.length > 0 && (
						<RelatedPosts items={relatedPosts} language={lang} />
					)}
				</div>

				<!-- Comments -->
				<div class="mt-8 bg-white dark:bg-gray-800 rounded-2xl shadow-sm p-4 sm:p-8 lg:p-12">
					<div class="giscus"></div>
				</div>

				<!-- Giscus Dynamic Theme Script -->
				<script is:inline define:vars={{ giscusLang: lang === 'ja' ? 'ja' : lang === 'en' ? 'en' : lang === 'zh' ? 'zh-CN' : 'ko' }}>
					function getGiscusTheme() {
						return document.documentElement.classList.contains('dark') ? 'dark' : 'light';
					}

					function setGiscusTheme(theme) {
						const iframe = document.querySelector('iframe.giscus-frame');
						if (iframe) {
							iframe.contentWindow.postMessage(
								{ giscus: { setConfig: { theme: theme } } },
								'https://giscus.app'
							);
						}
					}

					function loadGiscus() {
						const script = document.createElement('script');
						script.src = 'https://giscus.app/client.js';
						script.setAttribute('data-repo', 'kimjangwook/www.jangwook.net');
						script.setAttribute('data-repo-id', 'R_kgDOP8NyLg');
						script.setAttribute('data-category', 'Announcements');
						script.setAttribute('data-category-id', 'DIC_kwDOP8NyLs4CwRC3');
						script.setAttribute('data-mapping', 'pathname');
						script.setAttribute('data-strict', '0');
						script.setAttribute('data-reactions-enabled', '1');
						script.setAttribute('data-emit-metadata', '0');
						script.setAttribute('data-input-position', 'bottom');
						script.setAttribute('data-theme', getGiscusTheme());
						script.setAttribute('data-lang', giscusLang);
						script.setAttribute('data-loading', 'lazy');
						script.setAttribute('crossorigin', 'anonymous');
						script.async = true;
						document.querySelector('.giscus').appendChild(script);
					}

					// Load giscus on page load
					loadGiscus();

					// Listen for theme changes
					const observer = new MutationObserver((mutations) => {
						mutations.forEach((mutation) => {
							if (mutation.attributeName === 'class') {
								setGiscusTheme(getGiscusTheme());
							}
						});
					});

					observer.observe(document.documentElement, {
						attributes: true,
						attributeFilter: ['class']
					});
				</script>

				<!-- Back to blog link -->
				<div class="mt-8 text-center">
					<a
						href={`/${lang}/blog`}
						class="inline-flex items-center gap-2 text-accent hover:text-accent-dark font-medium transition-colors"
					>
						<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
							<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/>
						</svg>
						{lang === 'ko' ? '블로그 목록으로' : lang === 'ja' ? 'ブログリストへ' : lang === 'zh' ? '返回博客列表' : 'Back to Blog'}
					</a>
				</div>
			</article>
		</main>
		<Footer lang={lang} />

		<!-- Mermaid Diagram Rendering -->
		<script type="module">
			import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs';

			// Initialize Mermaid
			mermaid.initialize({
				startOnLoad: false,
				theme: 'default',
				securityLevel: 'loose',
				flowchart: {
					useMaxWidth: true,
					htmlLabels: true,
					curve: 'basis'
				}
			});

			// Find all mermaid code blocks and render them
			document.addEventListener('DOMContentLoaded', async () => {
				const mermaidBlocks = document.querySelectorAll('pre[data-language="mermaid"] code');

				mermaidBlocks.forEach(async (block, index) => {
					const code = block.textContent;
					const pre = block.parentElement;

					// Create a container for the mermaid diagram
					const container = document.createElement('div');
					container.className = 'mermaid-diagram';
					container.style.cssText = 'background: white; padding: 1rem; border-radius: 0.5rem; overflow-x: auto;';

					// Create unique ID for this diagram
					const id = `mermaid-${index}-${Date.now()}`;

					try {
						const { svg } = await mermaid.render(id, code);
						container.innerHTML = svg;
						pre.replaceWith(container);
					} catch (error) {
						console.error('Mermaid rendering error:', error);
						container.innerHTML = `<div style="color: red; padding: 1rem;">Mermaid diagram rendering failed</div>`;
						pre.replaceWith(container);
					}
				});
			});
		</script>

		<!-- Blog Post Read Complete Tracking -->
		<script is:inline>
			let scrollTracked = false;

			console.log('[GA Debug] Blog post read tracking initialized');

			function trackScrollComplete() {
				if (scrollTracked) {
					console.log('[GA Debug] Scroll already tracked, skipping');
					return;
				}

				const scrollHeight = document.documentElement.scrollHeight - window.innerHeight;
				const scrollPosition = window.scrollY;
				const scrollPercentage = (scrollPosition / scrollHeight) * 100;

				console.log('[GA Debug] Scroll position:', {
					scrollHeight,
					scrollPosition,
					scrollPercentage: scrollPercentage.toFixed(2) + '%'
				});

				if (scrollPercentage >= 100) {
					scrollTracked = true;
					console.log('[GA Debug] 100% scroll reached, firing event');

					// Send GA4 event
					if (typeof gtag !== 'undefined') {
						const eventData = {
							'page_title': document.title,
							'page_location': window.location.href,
							'page_path': window.location.pathname
						};
						console.log('[GA Debug] Sending blog_post_read_complete event:', eventData);
						gtag('event', 'blog_post_read_complete', eventData);
						console.log('[GA Debug] Event sent successfully');
					} else {
						console.warn('[GA Debug] gtag is not defined');
					}
				}
			}

			// Throttle scroll events
			let scrollTimeout;
			window.addEventListener('scroll', () => {
				clearTimeout(scrollTimeout);
				scrollTimeout = setTimeout(trackScrollComplete, 100);
			});
			console.log('[GA Debug] Scroll listener attached');
		</script>
	</body>
</html>
