---
title: Slack MCPã§ãƒãƒ¼ãƒ åˆ†æã‚’è‡ªå‹•åŒ–ã™ã‚‹å®Œå…¨ã‚¬ã‚¤ãƒ‰
description: >-
  Model Context
  Protocolæ´»ç”¨ã§Slackãƒ‡ãƒ¼ã‚¿ã‹ã‚‰æ„Ÿæƒ…åˆ†æãƒ»ã‚¨ãƒ³ã‚²ãƒ¼ã‚¸ãƒ¡ãƒ³ãƒˆæ¸¬å®šãƒ»è‡ªå‹•ã‚¤ãƒ³ã‚µã‚¤ãƒˆç”Ÿæˆã‚’å®Ÿç¾ã€‚å®Ÿè£…ã‹ã‚‰å¿œç”¨ã¾ã§ç¶²ç¾…çš„ã«è§£èª¬ã—ã¾ã™ã€‚
pubDate: '2025-11-04'
heroImage: ../../../assets/blog/slack-mcp-team-communication-hero.jpg
tags:
  - slack
  - mcp
  - ai-agents
  - communication-analytics
  - claude-code
relatedPosts:
  - slug: claude-skills-implementation-guide
    score: 0.95
    reason:
      ko: 'ìë™í™”, AI/ML, ì•„í‚¤í…ì²˜ ë¶„ì•¼ì—ì„œ ìœ ì‚¬í•œ ì£¼ì œë¥¼ ë‹¤ë£¨ë©° ë¹„ìŠ·í•œ ë‚œì´ë„ì…ë‹ˆë‹¤.'
      ja: è‡ªå‹•åŒ–ã€AI/MLã€ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£åˆ†é‡ã§é¡ä¼¼ã—ãŸãƒˆãƒ”ãƒƒã‚¯ã‚’æ‰±ã„ã€åŒç¨‹åº¦ã®é›£æ˜“åº¦ã§ã™ã€‚
      en: >-
        Covers similar topics in automation, AI/ML, architecture with comparable
        difficulty.
      zh: åœ¨è‡ªåŠ¨åŒ–ã€AI/MLã€æ¶æ„é¢†åŸŸæ¶µç›–ç±»ä¼¼ä¸»é¢˜ï¼Œéš¾åº¦ç›¸å½“ã€‚
  - slug: jules-autocoding
    score: 0.95
    reason:
      ko: 'ìë™í™”, AI/ML, ì•„í‚¤í…ì²˜ ë¶„ì•¼ì—ì„œ ìœ ì‚¬í•œ ì£¼ì œë¥¼ ë‹¤ë£¨ë©° ë¹„ìŠ·í•œ ë‚œì´ë„ì…ë‹ˆë‹¤.'
      ja: è‡ªå‹•åŒ–ã€AI/MLã€ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£åˆ†é‡ã§é¡ä¼¼ã—ãŸãƒˆãƒ”ãƒƒã‚¯ã‚’æ‰±ã„ã€åŒç¨‹åº¦ã®é›£æ˜“åº¦ã§ã™ã€‚
      en: >-
        Covers similar topics in automation, AI/ML, architecture with comparable
        difficulty.
      zh: åœ¨è‡ªåŠ¨åŒ–ã€AI/MLã€æ¶æ„é¢†åŸŸæ¶µç›–ç±»ä¼¼ä¸»é¢˜ï¼Œéš¾åº¦ç›¸å½“ã€‚
  - slug: ai-agent-notion-mcp-automation
    score: 0.94
    reason:
      ko: 'ìë™í™”, AI/ML, ì•„í‚¤í…ì²˜ ë¶„ì•¼ì—ì„œ ìœ ì‚¬í•œ ì£¼ì œë¥¼ ë‹¤ë£¨ë©° ë¹„ìŠ·í•œ ë‚œì´ë„ì…ë‹ˆë‹¤.'
      ja: è‡ªå‹•åŒ–ã€AI/MLã€ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£åˆ†é‡ã§é¡ä¼¼ã—ãŸãƒˆãƒ”ãƒƒã‚¯ã‚’æ‰±ã„ã€åŒç¨‹åº¦ã®é›£æ˜“åº¦ã§ã™ã€‚
      en: >-
        Covers similar topics in automation, AI/ML, architecture with comparable
        difficulty.
      zh: åœ¨è‡ªåŠ¨åŒ–ã€AI/MLã€æ¶æ„é¢†åŸŸæ¶µç›–ç±»ä¼¼ä¸»é¢˜ï¼Œéš¾åº¦ç›¸å½“ã€‚
  - slug: llm-pm-workflow-automation
    score: 0.94
    reason:
      ko: 'ìë™í™”, AI/ML ë¶„ì•¼ì—ì„œ ìœ ì‚¬í•œ ì£¼ì œë¥¼ ë‹¤ë£¨ë©° ë¹„ìŠ·í•œ ë‚œì´ë„ì…ë‹ˆë‹¤.'
      ja: è‡ªå‹•åŒ–ã€AI/MLåˆ†é‡ã§é¡ä¼¼ã—ãŸãƒˆãƒ”ãƒƒã‚¯ã‚’æ‰±ã„ã€åŒç¨‹åº¦ã®é›£æ˜“åº¦ã§ã™ã€‚
      en: 'Covers similar topics in automation, AI/ML with comparable difficulty.'
      zh: åœ¨è‡ªåŠ¨åŒ–ã€AI/MLé¢†åŸŸæ¶µç›–ç±»ä¼¼ä¸»é¢˜ï¼Œéš¾åº¦ç›¸å½“ã€‚
  - slug: notion-backlog-slack-claude-project-management
    score: 0.94
    reason:
      ko: 'ìë™í™”, AI/ML, ì•„í‚¤í…ì²˜ ë¶„ì•¼ì—ì„œ ìœ ì‚¬í•œ ì£¼ì œë¥¼ ë‹¤ë£¨ë©° ë¹„ìŠ·í•œ ë‚œì´ë„ì…ë‹ˆë‹¤.'
      ja: è‡ªå‹•åŒ–ã€AI/MLã€ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£åˆ†é‡ã§é¡ä¼¼ã—ãŸãƒˆãƒ”ãƒƒã‚¯ã‚’æ‰±ã„ã€åŒç¨‹åº¦ã®é›£æ˜“åº¦ã§ã™ã€‚
      en: >-
        Covers similar topics in automation, AI/ML, architecture with comparable
        difficulty.
      zh: åœ¨è‡ªåŠ¨åŒ–ã€AI/MLã€æ¶æ„é¢†åŸŸæ¶µç›–ç±»ä¼¼ä¸»é¢˜ï¼Œéš¾åº¦ç›¸å½“ã€‚
---

## æ¦‚è¦

ä¼æ¥­ã®ã‚³ãƒŸãƒ¥ãƒ‹ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãƒãƒ–ã¨ã—ã¦æ©Ÿèƒ½ã™ã‚‹Slackã«ã¯ã€ãƒãƒ¼ãƒ ã®å¥å…¨æ€§ã€ç”Ÿç”£æ€§ã€æ–‡åŒ–ã‚’ç†è§£ã™ã‚‹ãŸã‚ã®è²´é‡ãªãƒ‡ãƒ¼ã‚¿ãŒè“„ç©ã•ã‚Œã¦ã„ã¾ã™ã€‚ã—ã‹ã—ã€ã“ã®ãƒ‡ãƒ¼ã‚¿ã‚’åŠ¹æœçš„ã«åˆ†æã—ã€ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã«ã¤ãªã’ã‚‹ã“ã¨ã¯å®¹æ˜“ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚

Model Context Protocol (MCP) ã¯ã€AnthropicãŒé–‹ç™ºã—ãŸæ–°ã—ã„æ¨™æº–ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã§ã€AI ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒå¤–éƒ¨ã‚·ã‚¹ãƒ†ãƒ ã¨çµ±åˆã™ã‚‹æ–¹æ³•ã‚’çµ±ä¸€ã—ã¾ã™ã€‚Slack MCPã‚’æ´»ç”¨ã™ã‚‹ã“ã¨ã§ã€ã“ã‚Œã¾ã§è¤‡é›‘ã ã£ãŸSlackãƒ‡ãƒ¼ã‚¿ã®åˆ†æãŒåŠ‡çš„ã«ç°¡ç´ åŒ–ã•ã‚Œã¾ã™ã€‚

<strong>ã“ã®è¨˜äº‹ã§æ‰±ã†å†…å®¹:</strong>

- Slack MCPã®æ ¸å¿ƒæ¦‚å¿µã¨ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£
- 3ã¤ã®å®Ÿè£…ã‚ªãƒ—ã‚·ãƒ§ãƒ³ (å…¬å¼TypeScriptã€Pythonã€Browser Tokenæ–¹å¼)
- 8ã¤ã®æ ¸å¿ƒMCPãƒ„ãƒ¼ãƒ«ã®å®Ÿè·µæ´»ç”¨æ³•
- æ„Ÿæƒ…åˆ†æã€ã‚¨ãƒ³ã‚²ãƒ¼ã‚¸ãƒ¡ãƒ³ãƒˆæ¸¬å®šã€çµµæ–‡å­—ãƒ‘ã‚¿ãƒ¼ãƒ³åˆ†æ
- å®Ÿéš›ã®ä¼æ¥­äº‹ä¾‹ (Salesforceã€ã‚«ã‚¹ã‚¿ãƒãƒ¼ã‚µãƒãƒ¼ãƒˆã€ãƒªãƒ¢ãƒ¼ãƒˆãƒãƒ¼ãƒ )
- ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–ã¨ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã®ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹

## Slack MCPã¨ã¯ä½•ã‹?

### æ ¸å¿ƒæ¦‚å¿µ

Model Context Protocol (MCP) ã¯ã€LLMã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã¨ãƒ‡ãƒ¼ã‚¿ã‚½ãƒ¼ã‚¹é–“ã®æ¨™æº–åŒ–ã•ã‚ŒãŸã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’æä¾›ã—ã¾ã™ã€‚å¾“æ¥ã®Slack APIãŒé–‹ç™ºè€…ã«RESTã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚’æä¾›ã™ã‚‹ã®ã«å¯¾ã—ã€Slack MCPã¯AIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒè‡ªç„¶è¨€èªã§Slackã¨å¯¾è©±ã§ãã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚

````mermaid
graph LR
    A[Claude AI] -->|MCP Protocol| B[Slack MCP Server]
    B -->|Slack API| C[Slack Workspace]
    B -->|Data Processing| D[Analysis Tools]
    D -->|Insights| A

    style A fill:#4A90E2
    style B fill:#E94B3C
    style C fill:#611F69
    style D fill:#2EB67D
````

<strong>å¾“æ¥ã®Slack APIã¨ã®ä¸»ãªé•ã„:</strong>

| å´é¢ | å¾“æ¥ã®Slack API | Slack MCP |
|------|----------------|-----------|
| <strong>ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹</strong> | REST API | æ¨™æº–åŒ–ãƒ—ãƒ­ãƒˆã‚³ãƒ« |
| <strong>å¯¾è±¡ãƒ¦ãƒ¼ã‚¶ãƒ¼</strong> | é–‹ç™ºè€… | AIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ |
| <strong>çµ±åˆã®è¤‡é›‘ã•</strong> | é«˜ (èªè¨¼ã€ãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³ã€ã‚¨ãƒ©ãƒ¼å‡¦ç†) | ä½ (MCPãŒæŠ½è±¡åŒ–) |
| <strong>æ‹¡å¼µæ€§</strong> | å€‹åˆ¥å®Ÿè£… | æ¨™æº–ãƒ„ãƒ¼ãƒ«ã‚»ãƒƒãƒˆ |
| <strong>AIçµ±åˆ</strong> | ã‚«ã‚¹ã‚¿ãƒ å®Ÿè£…å¿…è¦ | ãƒã‚¤ãƒ†ã‚£ãƒ–ã‚µãƒãƒ¼ãƒˆ |

### ä¸»è¦æ§‹æˆè¦ç´ 

Slack MCPã‚¨ã‚³ã‚·ã‚¹ãƒ†ãƒ ã¯3ã¤ã®ä¸»è¦è¦ç´ ã§æ§‹æˆã•ã‚Œã¾ã™:

1. <strong>MCP Hosts</strong>: AIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆå®Ÿè¡Œç’°å¢ƒ (Claude Codeã€Claude Desktopã€ã‚«ã‚¹ã‚¿ãƒ ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³)
2. <strong>MCP Servers</strong>: Slackã¨ã®é€šä¿¡ã‚’å‡¦ç†ã™ã‚‹ä¸­é–“å±¤ (å…¬å¼/ã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£ã‚µãƒ¼ãƒãƒ¼)
3. <strong>ãƒ—ãƒ­ãƒˆã‚³ãƒ«æ¨™æº–</strong>: Resources (ãƒ‡ãƒ¼ã‚¿ã‚½ãƒ¼ã‚¹)ã€Tools (æ“ä½œ)ã€Prompts (ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ)

## ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã¨è¨­å®š

Slack MCPã«ã¯3ã¤ã®å®Ÿè£…ã‚ªãƒ—ã‚·ãƒ§ãƒ³ãŒã‚ã‚Šã€ãã‚Œãã‚Œç•°ãªã‚‹è¦ä»¶ã¨ãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹ã«å¯¾å¿œã—ã¾ã™ã€‚

### Option 1: å…¬å¼TypeScriptã‚µãƒ¼ãƒãƒ¼ (æ¨å¥¨)

Anthropicå…¬å¼ã®TypeScriptå®Ÿè£…ã¯ã€æœ€ã‚‚å®‰å®šã—ã¦ãŠã‚Šã€ä¼æ¥­ç’°å¢ƒã«é©ã—ã¦ã„ã¾ã™ã€‚

<strong>ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«æ‰‹é †:</strong>

```bash
# NPMã‹ã‚‰ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
npm install -g @modelcontextprotocol/server-slack

# ã¾ãŸã¯ç‰¹å®šãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã«è¿½åŠ 
npm install @modelcontextprotocol/server-slack
```

<strong>Claude Desktopè¨­å®š (claude_desktop_config.json):</strong>

```json
{
  "mcpServers": {
    "slack": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-slack"],
      "env": {
        "SLACK_BOT_TOKEN": "xoxb-your-bot-token",
        "SLACK_TEAM_ID": "T01234567"
      }
    }
  }
}
```

<strong>ç’°å¢ƒå¤‰æ•°è¨­å®š:</strong>

```bash
# .envãƒ•ã‚¡ã‚¤ãƒ«ã«è¿½åŠ 
SLACK_BOT_TOKEN=xoxb-your-bot-token-here
SLACK_TEAM_ID=T01234567
```

### Option 2: ã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£Pythonã‚µãƒ¼ãƒãƒ¼

Pythoné–‹ç™ºè€…ã‚„ãƒ‡ãƒ¼ã‚¿ã‚µã‚¤ã‚¨ãƒ³ãƒ†ã‚£ã‚¹ãƒˆã«ã¯ã€ã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£ãŒæä¾›ã™ã‚‹Pythonå®Ÿè£…ãŒä¾¿åˆ©ã§ã™ã€‚

<strong>ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«:</strong>

```bash
# pipã‚’ä½¿ç”¨
pip install slack-mcp-server

# ã¾ãŸã¯è©© (Poetry) ã‚’ä½¿ç”¨
poetry add slack-mcp-server
```

<strong>è¨­å®šä¾‹ (config.yaml):</strong>

```yaml
mcp:
  servers:
    slack:
      command: python
      args:
        - -m
        - slack_mcp_server
      env:
        SLACK_BOT_TOKEN: ${SLACK_BOT_TOKEN}
        SLACK_TEAM_ID: ${SLACK_TEAM_ID}
```

<strong>ãƒ¡ãƒªãƒƒãƒˆã¨ãƒ‡ãƒ¡ãƒªãƒƒãƒˆ:</strong>

âœ… <strong>ãƒ¡ãƒªãƒƒãƒˆ:</strong>
- Pythonã‚¨ã‚³ã‚·ã‚¹ãƒ†ãƒ ã¨ã®çµ±åˆãŒå®¹æ˜“
- ãƒ‡ãƒ¼ã‚¿åˆ†æãƒ©ã‚¤ãƒ–ãƒ©ãƒª (pandasã€numpy) ã¨ã®è¦ªå’Œæ€§
- Jupyter Notebookã§ã®å®Ÿé¨“ãŒå¯èƒ½

âŒ <strong>ãƒ‡ãƒ¡ãƒªãƒƒãƒˆ:</strong>
- å…¬å¼ã‚µãƒãƒ¼ãƒˆã§ã¯ãªã„
- ä¸€éƒ¨æ©Ÿèƒ½ãŒåˆ¶é™ã•ã‚Œã‚‹å¯èƒ½æ€§
- ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ãƒˆãŒé…ã‚Œã‚‹å ´åˆãŒã‚ã‚‹

### Option 3: é«˜åº¦ãªã‚µãƒ¼ãƒãƒ¼ (Browser Tokenæ–¹å¼)

ç®¡ç†è€…æ¨©é™ãŒãªã„ç’°å¢ƒã‚„ã€Bot Tokenå–å¾—ãŒå›°é›£ãªå ´åˆã®ä»£æ›¿æ‰‹æ®µã§ã™ã€‚

<strong>ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«:</strong>

```bash
npx -y @modelcontextprotocol/create-server slack-unofficial
```

<strong>Browser Tokenå–å¾—æ–¹æ³•:</strong>

1. Slack Webã‚¢ãƒ—ãƒªã«ãƒ­ã‚°ã‚¤ãƒ³
2. é–‹ç™ºè€…ãƒ„ãƒ¼ãƒ« (F12) ã‚’é–‹ã
3. Application â†’ Cookies â†’ `d` å€¤ã‚’ã‚³ãƒ”ãƒ¼
4. è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã« `SLACK_COOKIE_TOKEN` ã¨ã—ã¦è¨­å®š

<strong>è¨­å®šä¾‹:</strong>

```json
{
  "mcpServers": {
    "slack-unofficial": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-slack-unofficial"],
      "env": {
        "SLACK_COOKIE_TOKEN": "xoxd-your-cookie-token",
        "SLACK_TEAM_ID": "T01234567"
      }
    }
  }
}
```

<strong>ä½¿ç”¨ã‚·ãƒŠãƒªã‚ª:</strong>
- å€‹äººçš„ãªå®Ÿé¨“ã‚„ãƒ—ãƒ­ãƒˆã‚¿ã‚¤ãƒ”ãƒ³ã‚°
- ç®¡ç†è€…æ¨©é™ã®ãªã„ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹
- ä¸€æ™‚çš„ãªãƒ‡ãƒ¼ã‚¿åˆ†æ

âš ï¸ <strong>æ³¨æ„:</strong> Browser Tokenã¯å…¬å¼ã«ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ãŠã‚‰ãšã€ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒªã‚¹ã‚¯ãŒã‚ã‚Šã¾ã™ã€‚æœ¬ç•ªç’°å¢ƒã§ã¯ä½¿ç”¨ã—ãªã„ã§ãã ã•ã„ã€‚

### èªè¨¼ã¨æ¨©é™è¨­å®š

<strong>Slack Appä½œæˆæ‰‹é †:</strong>

1. [Slack API Portal](https://api.slack.com/apps) ã«ã‚¢ã‚¯ã‚»ã‚¹
2. "Create New App" â†’ "From scratch" ã‚’é¸æŠ
3. ã‚¢ãƒ—ãƒªåã¨ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹ã‚’é¸æŠ
4. OAuth & Permissions ã§å¿…è¦ãªã‚¹ã‚³ãƒ¼ãƒ—ã‚’è¿½åŠ 
5. Bot User OAuth Token ã‚’ã‚³ãƒ”ãƒ¼

<strong>å¿…é ˆOAuthã‚¹ã‚³ãƒ¼ãƒ—:</strong>

```text
# ãƒãƒ£ãƒ³ãƒãƒ«æ“ä½œ
channels:history     # ãƒ‘ãƒ–ãƒªãƒƒã‚¯ãƒãƒ£ãƒ³ãƒãƒ«ã®å±¥æ­´èª­å–
channels:read        # ãƒãƒ£ãƒ³ãƒãƒ«æƒ…å ±å–å¾—
groups:history       # ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆãƒãƒ£ãƒ³ãƒãƒ«ã®å±¥æ­´èª­å–
groups:read          # ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆãƒãƒ£ãƒ³ãƒãƒ«æƒ…å ±å–å¾—

# ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æ“ä½œ
chat:write           # ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡
reactions:read       # ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³èª­å–
reactions:write      # ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³è¿½åŠ 

# ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±
users:read           # ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±å–å¾—
users:read.email     # ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹å–å¾— (ã‚ªãƒ—ã‚·ãƒ§ãƒ³)

# æ¤œç´¢
search:read          # ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æ¤œç´¢
```

<strong>Bot Token vs User Token vs Browser Token:</strong>

| ãƒˆãƒ¼ã‚¯ãƒ³ã‚¿ã‚¤ãƒ— | ç”¨é€” | ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ | æ¨å¥¨åº¦ |
|--------------|------|------------|-------|
| <strong>Bot Token</strong> | è‡ªå‹•åŒ–ã€åˆ†æ | é«˜ | â­â­â­â­â­ |
| <strong>User Token</strong> | ãƒ¦ãƒ¼ã‚¶ãƒ¼ä»£ç†æ“ä½œ | ä¸­ | â­â­â­ |
| <strong>Browser Token</strong> | é–‹ç™ºãƒ»ãƒ†ã‚¹ãƒˆ | ä½ | â­ |

## åˆ©ç”¨å¯èƒ½ãªMCPãƒ„ãƒ¼ãƒ«

Slack MCPã¯8ã¤ã®æ ¸å¿ƒãƒ„ãƒ¼ãƒ«ã‚’æä¾›ã—ã€ãƒãƒ¼ãƒ åˆ†æã®åŸºç›¤ã¨ãªã‚Šã¾ã™ã€‚

### 1. slack_list_channels - ãƒãƒ£ãƒ³ãƒãƒ«ãƒªã‚¹ãƒˆå–å¾—

<strong>ç”¨é€”:</strong> ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹å†…ã®ã™ã¹ã¦ã®ãƒãƒ£ãƒ³ãƒãƒ«ã‚’å–å¾—ã—ã€åˆ†æå¯¾è±¡ã‚’ç‰¹å®šã—ã¾ã™ã€‚

<strong>ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ä¾‹:</strong>

```typescript
// TypeScriptã§ã®ä½¿ç”¨ä¾‹
const channels = await mcp.callTool('slack_list_channels', {
  types: 'public_channel,private_channel',
  exclude_archived: true,
  limit: 100
});
```

<strong>ãƒ¬ã‚¹ãƒãƒ³ã‚¹å½¢å¼:</strong>

```json
{
  "channels": [
    {
      "id": "C01234567",
      "name": "general",
      "is_channel": true,
      "is_private": false,
      "is_archived": false,
      "num_members": 150,
      "topic": {
        "value": "ä¼šç¤¾å…¨ä½“ã®ã‚¢ãƒŠã‚¦ãƒ³ã‚¹"
      },
      "purpose": {
        "value": "å…¨ç¤¾ã‚³ãƒŸãƒ¥ãƒ‹ã‚±ãƒ¼ã‚·ãƒ§ãƒ³"
      }
    }
  ]
}
```

<strong>å®Ÿè·µæ´»ç”¨äº‹ä¾‹:</strong>
- ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªãƒãƒ£ãƒ³ãƒãƒ«ã®è­˜åˆ¥
- ãƒãƒ£ãƒ³ãƒãƒ«å‘½åè¦å‰‡ã®ç›£æŸ»
- ä¼‘çœ ãƒãƒ£ãƒ³ãƒãƒ«ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—

### 2. slack_conversations_history - ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å±¥æ­´

<strong>ç”¨é€”:</strong> ç‰¹å®šãƒãƒ£ãƒ³ãƒãƒ«ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å±¥æ­´ã‚’å–å¾—ã—ã€æ™‚ç³»åˆ—åˆ†æã‚’å®Ÿè¡Œã—ã¾ã™ã€‚

<strong>ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ä¾‹:</strong>

```typescript
const messages = await mcp.callTool('slack_conversations_history', {
  channel: 'C01234567',
  limit: 100,
  oldest: '1609459200', // Unix timestamp
  latest: '1640995200'
});
```

<strong>å®Ÿè·µæ´»ç”¨äº‹ä¾‹:</strong>
- ãƒ”ãƒ¼ã‚¯æ™‚é–“å¸¯ã®åˆ†æ
- ãƒˆãƒ”ãƒƒã‚¯ãƒˆãƒ¬ãƒ³ãƒ‰ã®è¿½è·¡
- å•é¡Œè§£æ±ºæ™‚é–“ã®æ¸¬å®š

### 3. slack_post_message - ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡

<strong>ç”¨é€”:</strong> åˆ†æçµæœã‚„ã‚¢ãƒ©ãƒ¼ãƒˆã‚’ãƒãƒ£ãƒ³ãƒãƒ«ã«è‡ªå‹•æŠ•ç¨¿ã—ã¾ã™ã€‚

<strong>ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ä¾‹:</strong>

```typescript
await mcp.callTool('slack_post_message', {
  channel: 'C01234567',
  text: 'é€±æ¬¡ãƒ¬ãƒãƒ¼ãƒˆ: ä»Šé€±ã®ã‚¨ãƒ³ã‚²ãƒ¼ã‚¸ãƒ¡ãƒ³ãƒˆã¯å‰é€±æ¯”15%å¢—åŠ ã—ã¾ã—ãŸ',
  blocks: [
    {
      type: 'section',
      text: {
        type: 'mrkdwn',
        text: '*é€±æ¬¡ã‚³ãƒŸãƒ¥ãƒ‹ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãƒ¬ãƒãƒ¼ãƒˆ*\nâ€¢ ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æ•°: 1,234\nâ€¢ ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ¦ãƒ¼ã‚¶ãƒ¼: 87\nâ€¢ å¹³å‡å¿œç­”æ™‚é–“: 2.3æ™‚é–“'
      }
    }
  ]
});
```

### 4. slack_reply_to_thread - ã‚¹ãƒ¬ãƒƒãƒ‰è¿”ä¿¡

<strong>ç”¨é€”:</strong> æ—¢å­˜ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã«ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’ä¿æŒã—ã¦è¿”ä¿¡ã—ã¾ã™ã€‚

<strong>ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ä¾‹:</strong>

```typescript
await mcp.callTool('slack_reply_to_thread', {
  channel: 'C01234567',
  thread_ts: '1640995200.123456',
  text: 'ã“ã®å•é¡Œã¯é¡ä¼¼ã®ã‚±ãƒ¼ã‚¹3ä»¶ã§å¹³å‡è§£æ±ºæ™‚é–“ãŒ4.5æ™‚é–“ã§ã—ãŸ'
});
```

### 5. slack_add_reaction - çµµæ–‡å­—ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³

<strong>ç”¨é€”:</strong> ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã«çµµæ–‡å­—ã‚’è¿½åŠ ã—ã€éè¨€èªçš„ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ã‚’æä¾›ã—ã¾ã™ã€‚

<strong>ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ä¾‹:</strong>

```typescript
await mcp.callTool('slack_add_reaction', {
  channel: 'C01234567',
  timestamp: '1640995200.123456',
  name: 'white_check_mark'
});
```

<strong>å®Ÿè·µæ´»ç”¨äº‹ä¾‹:</strong>
- è‡ªå‹•æ‰¿èªã‚·ã‚¹ãƒ†ãƒ 
- ã‚¿ã‚¹ã‚¯å®Œäº†ã®å¯è¦–åŒ–
- ãƒãƒ¼ãƒ å£«æ°—ã®æ¸¬å®š

### 6. slack_get_thread_replies - ã‚¹ãƒ¬ãƒƒãƒ‰è¿”ä¿¡å–å¾—

<strong>ç”¨é€”:</strong> ã‚¹ãƒ¬ãƒƒãƒ‰å†…ã®ã™ã¹ã¦ã®è¿”ä¿¡ã‚’å–å¾—ã—ã€ä¼šè©±ã®æ·±ã•ã‚’åˆ†æã—ã¾ã™ã€‚

<strong>ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ä¾‹:</strong>

```typescript
const replies = await mcp.callTool('slack_get_thread_replies', {
  channel: 'C01234567',
  ts: '1640995200.123456'
});

// ä¼šè©±ã®æ·±ã•åˆ†æ
const threadDepth = replies.messages.length;
const avgResponseTime = calculateAvgResponseTime(replies.messages);
```

### 7. slack_list_users - ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒªã‚¹ãƒˆ

<strong>ç”¨é€”:</strong> ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹ã®ã™ã¹ã¦ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã‚’å–å¾—ã—ã¾ã™ã€‚

<strong>ãƒ¬ã‚¹ãƒãƒ³ã‚¹å½¢å¼:</strong>

```json
{
  "members": [
    {
      "id": "U01234567",
      "name": "tanaka.taro",
      "real_name": "ç”°ä¸­å¤ªéƒ",
      "profile": {
        "email": "tanaka@example.com",
        "title": "ã‚·ãƒ‹ã‚¢ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢",
        "status_text": "åœ¨å®…å‹¤å‹™ä¸­",
        "status_emoji": ":house:"
      },
      "is_bot": false,
      "is_admin": false
    }
  ]
}
```

### 8. slack_search_messages - ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æ¤œç´¢

<strong>ç”¨é€”:</strong> é«˜åº¦ãªã‚¯ã‚¨ãƒªã§ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æ¤œç´¢ã—ã¾ã™ã€‚

<strong>ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ä¾‹:</strong>

```typescript
const results = await mcp.callTool('slack_search_messages', {
  query: 'ã‚¨ãƒ©ãƒ¼ OR éšœå®³ in:#engineering after:2025-01-01',
  count: 50,
  sort: 'timestamp',
  sort_dir: 'desc'
});
```

<strong>é«˜åº¦ãªæ¤œç´¢ã‚¯ã‚¨ãƒªä¾‹:</strong>

- `from:@tanaka has::thumbsup:` - ç”°ä¸­ã•ã‚“ã®æŠ•ç¨¿ã§ğŸ‘ãŒä»˜ã„ãŸã‚‚ã®
- `in:#general during:January` - 1æœˆã®generalãƒãƒ£ãƒ³ãƒãƒ«æŠ•ç¨¿
- `"ãƒ‡ãƒ—ãƒ­ã‚¤å®Œäº†" has:link` - ãƒªãƒ³ã‚¯ä»˜ãã®ãƒ‡ãƒ—ãƒ­ã‚¤å®Œäº†ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸

## ãƒ‡ãƒ¼ã‚¿åˆ†ææ‰‹æ³•

### 1. ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒœãƒªãƒ¥ãƒ¼ãƒ åˆ†æ

ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æ•°ã®æ¨ç§»ã‚’åˆ†æã™ã‚‹ã“ã¨ã§ã€ãƒãƒ¼ãƒ ã®æ´»å‹•ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ç†è§£ã§ãã¾ã™ã€‚

<strong>å®Ÿè£…ä¾‹ (TypeScript):</strong>

```typescript
interface MessageVolume {
  date: string;
  hour: number;
  count: number;
  channelId: string;
}

async function analyzeMessageVolume(
  channelId: string,
  days: number = 30
): Promise<MessageVolume[]> {
  const now = Date.now() / 1000;
  const oldest = now - (days * 24 * 60 * 60);

  const messages = await mcp.callTool('slack_conversations_history', {
    channel: channelId,
    oldest: oldest.toString(),
    limit: 1000
  });

  const volumeMap = new Map<string, number>();

  for (const msg of messages.messages) {
    const timestamp = parseFloat(msg.ts);
    const date = new Date(timestamp * 1000);
    const dateHour = `${date.toISOString().split('T')[0]}-${date.getHours()}`;

    volumeMap.set(dateHour, (volumeMap.get(dateHour) || 0) + 1);
  }

  return Array.from(volumeMap.entries()).map(([key, count]) => {
    const [date, hour] = key.split('-');
    return { date, hour: parseInt(hour), count, channelId };
  });
}

// ä½¿ç”¨ä¾‹
const volume = await analyzeMessageVolume('C01234567', 30);
const peakHours = volume
  .sort((a, b) => b.count - a.count)
  .slice(0, 5);

console.log('ãƒ”ãƒ¼ã‚¯æ™‚é–“å¸¯:', peakHours);
```

<strong>åˆ†æçµæœã®æ´»ç”¨:</strong>
- ãƒŸãƒ¼ãƒ†ã‚£ãƒ³ã‚°æ™‚é–“ã®æœ€é©åŒ–
- ã‚µãƒãƒ¼ãƒˆäººå“¡é…ç½®ã®èª¿æ•´
- ç•°å¸¸ãªã‚¢ã‚¯ãƒ†ã‚£ãƒ“ãƒ†ã‚£ã®æ¤œå‡º

### 2. æ„Ÿæƒ…åˆ†æ

Claude AIã‚’æ´»ç”¨ã—ã¦ã€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®æ„Ÿæƒ…ã‚’åˆ†æã—ã€ãƒãƒ¼ãƒ å£«æ°—ã‚’ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°ã—ã¾ã™ã€‚

<strong>å®Ÿè£…ä¾‹:</strong>

```typescript
interface SentimentScore {
  message: string;
  score: number; // -1 (éå¸¸ã«ãƒã‚¬ãƒ†ã‚£ãƒ–) ã€œ 1 (éå¸¸ã«ãƒã‚¸ãƒ†ã‚£ãƒ–)
  confidence: number;
  timestamp: string;
}

async function analyzeSentiment(
  messages: any[]
): Promise<SentimentScore[]> {
  const results: SentimentScore[] = [];

  for (const msg of messages) {
    // Claude APIã§æ„Ÿæƒ…åˆ†æ
    const sentiment = await claude.analyze({
      prompt: `ä»¥ä¸‹ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®æ„Ÿæƒ…ã‚’-1ã‹ã‚‰1ã®ç¯„å›²ã§è©•ä¾¡ã—ã¦ãã ã•ã„ã€‚
      -1: éå¸¸ã«ãƒã‚¬ãƒ†ã‚£ãƒ–
      0: ä¸­ç«‹
      1: éå¸¸ã«ãƒã‚¸ãƒ†ã‚£ãƒ–

      ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸: "${msg.text}"

      JSONå½¢å¼ã§è¿”ã—ã¦ãã ã•ã„: {"score": 0.5, "confidence": 0.9, "reason": "ç†ç”±"}`,
      model: 'claude-3-5-sonnet-20241022'
    });

    const parsed = JSON.parse(sentiment.content);
    results.push({
      message: msg.text,
      score: parsed.score,
      confidence: parsed.confidence,
      timestamp: msg.ts
    });
  }

  return results;
}

// ãƒãƒ¼ãƒ å£«æ°—ã‚¹ã‚³ã‚¢è¨ˆç®—
function calculateTeamMorale(sentiments: SentimentScore[]): number {
  const weightedSum = sentiments.reduce((sum, s) =>
    sum + (s.score * s.confidence), 0
  );
  const totalWeight = sentiments.reduce((sum, s) =>
    sum + s.confidence, 0
  );

  return weightedSum / totalWeight;
}
```

<strong>å®Ÿè·µæ´»ç”¨:</strong>
- é€±æ¬¡ãƒãƒ¼ãƒ å£«æ°—ãƒ¬ãƒãƒ¼ãƒˆ
- ãƒã‚¬ãƒ†ã‚£ãƒ–ãƒˆãƒ¬ãƒ³ãƒ‰ã®æ—©æœŸæ¤œå‡º
- ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã¸ã®è‡ªå‹•ã‚¢ãƒ©ãƒ¼ãƒˆ

### 3. ã‚¹ãƒ¬ãƒƒãƒ‰ã¨ä¼šè©±åˆ†æ

ã‚¹ãƒ¬ãƒƒãƒ‰ã®ã‚¨ãƒ³ã‚²ãƒ¼ã‚¸ãƒ¡ãƒ³ãƒˆã‚’æ¸¬å®šã—ã€åŠ¹æœçš„ãªã‚³ãƒŸãƒ¥ãƒ‹ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ç‰¹å®šã—ã¾ã™ã€‚

<strong>å®Ÿè£…ä¾‹:</strong>

```typescript
interface ThreadMetrics {
  threadId: string;
  replyCount: number;
  participantCount: number;
  avgResponseTimeMinutes: number;
  resolutionStatus: 'resolved' | 'ongoing' | 'abandoned';
  engagementScore: number;
}

async function analyzeThreadEngagement(
  channelId: string,
  threadTs: string
): Promise<ThreadMetrics> {
  const replies = await mcp.callTool('slack_get_thread_replies', {
    channel: channelId,
    ts: threadTs
  });

  const messages = replies.messages;
  const participants = new Set(messages.map(m => m.user));

  // å¿œç­”æ™‚é–“è¨ˆç®—
  const responseTimes: number[] = [];
  for (let i = 1; i < messages.length; i++) {
    const prevTime = parseFloat(messages[i-1].ts);
    const currTime = parseFloat(messages[i].ts);
    responseTimes.push((currTime - prevTime) / 60); // åˆ†å˜ä½
  }

  const avgResponseTime = responseTimes.reduce((a, b) => a + b, 0) / responseTimes.length;

  // è§£æ±ºçŠ¶æ…‹åˆ¤å®š
  const lastMessage = messages[messages.length - 1];
  const hasResolutionReaction = lastMessage.reactions?.some(r =>
    ['white_check_mark', 'heavy_check_mark', 'ok'].includes(r.name)
  );

  const hoursSinceLastReply = (Date.now() / 1000 - parseFloat(lastMessage.ts)) / 3600;

  let resolutionStatus: 'resolved' | 'ongoing' | 'abandoned';
  if (hasResolutionReaction) {
    resolutionStatus = 'resolved';
  } else if (hoursSinceLastReply > 72) {
    resolutionStatus = 'abandoned';
  } else {
    resolutionStatus = 'ongoing';
  }

  // ã‚¨ãƒ³ã‚²ãƒ¼ã‚¸ãƒ¡ãƒ³ãƒˆã‚¹ã‚³ã‚¢ (0ã€œ100)
  const engagementScore = Math.min(100,
    (messages.length * 10) +
    (participants.size * 5) +
    (hasResolutionReaction ? 20 : 0)
  );

  return {
    threadId: threadTs,
    replyCount: messages.length - 1,
    participantCount: participants.size,
    avgResponseTimeMinutes: avgResponseTime,
    resolutionStatus,
    engagementScore
  };
}
```

### 4. çµµæ–‡å­—ã¨ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒ‘ã‚¿ãƒ¼ãƒ³åˆ†æ

éè¨€èªçš„ã‚³ãƒŸãƒ¥ãƒ‹ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’åˆ†æã—ã€ãƒãƒ¼ãƒ æ–‡åŒ–ã‚’ç†è§£ã—ã¾ã™ã€‚

<strong>å®Ÿè£…ä¾‹:</strong>

```typescript
interface EmojiAnalytics {
  emoji: string;
  count: number;
  usedBy: string[];
  contexts: string[];
  sentiment: 'positive' | 'neutral' | 'negative';
}

async function analyzeEmojiPatterns(
  channelId: string,
  days: number = 30
): Promise<EmojiAnalytics[]> {
  const messages = await fetchRecentMessages(channelId, days);
  const emojiMap = new Map<string, EmojiAnalytics>();

  for (const msg of messages) {
    if (!msg.reactions) continue;

    for (const reaction of msg.reactions) {
      const emoji = reaction.name;

      if (!emojiMap.has(emoji)) {
        emojiMap.set(emoji, {
          emoji,
          count: 0,
          usedBy: [],
          contexts: [],
          sentiment: classifyEmojiSentiment(emoji)
        });
      }

      const analytics = emojiMap.get(emoji)!;
      analytics.count += reaction.count;
      analytics.usedBy.push(...reaction.users);
      analytics.contexts.push(msg.text.substring(0, 100));
    }
  }

  return Array.from(emojiMap.values())
    .sort((a, b) => b.count - a.count);
}

function classifyEmojiSentiment(emoji: string): 'positive' | 'neutral' | 'negative' {
  const positiveEmojis = ['thumbsup', 'heart', 'tada', 'clap', 'fire', 'star'];
  const negativeEmojis = ['disappointed', 'confused', 'x', 'warning'];

  if (positiveEmojis.includes(emoji)) return 'positive';
  if (negativeEmojis.includes(emoji)) return 'negative';
  return 'neutral';
}

// ãƒãƒ¼ãƒ æ–‡åŒ–æŒ‡æ¨™è¨ˆç®—
function calculateCultureScore(emojiAnalytics: EmojiAnalytics[]): {
  positivity: number;
  engagement: number;
  diversity: number;
} {
  const totalCount = emojiAnalytics.reduce((sum, e) => sum + e.count, 0);
  const positiveCount = emojiAnalytics
    .filter(e => e.sentiment === 'positive')
    .reduce((sum, e) => sum + e.count, 0);

  return {
    positivity: (positiveCount / totalCount) * 100,
    engagement: totalCount / 30, // 1æ—¥ã‚ãŸã‚Š
    diversity: emojiAnalytics.length
  };
}
```

### 5. ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¨ãƒ³ã‚²ãƒ¼ã‚¸ãƒ¡ãƒ³ãƒˆæŒ‡æ¨™

å¤šæ¬¡å…ƒçš„ã«ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ã‚¨ãƒ³ã‚²ãƒ¼ã‚¸ãƒ¡ãƒ³ãƒˆã‚’æ¸¬å®šã—ã¾ã™ã€‚

<strong>å®Ÿè£…ä¾‹:</strong>

```typescript
interface UserEngagement {
  userId: string;
  userName: string;
  metrics: {
    messageCount: number;
    threadParticipation: number;
    reactionsGiven: number;
    reactionsReceived: number;
    avgResponseTimeMinutes: number;
    channelsActive: number;
    influenceScore: number;
  };
}

async function calculateUserEngagement(
  userId: string,
  days: number = 30
): Promise<UserEngagement> {
  const channels = await mcp.callTool('slack_list_channels', {});
  const user = await mcp.callTool('slack_users_info', { user: userId });

  let totalMessages = 0;
  let totalThreads = 0;
  let reactionsGiven = 0;
  let reactionsReceived = 0;
  let activeChannels = 0;

  for (const channel of channels.channels) {
    const messages = await fetchUserMessages(channel.id, userId, days);

    if (messages.length > 0) activeChannels++;
    totalMessages += messages.length;

    for (const msg of messages) {
      if (msg.thread_ts && msg.thread_ts !== msg.ts) {
        totalThreads++;
      }

      if (msg.reactions) {
        reactionsReceived += msg.reactions.reduce((sum, r) => sum + r.count, 0);
      }
    }
  }

  // å½±éŸ¿åŠ›ã‚¹ã‚³ã‚¢è¨ˆç®— (0ã€œ100)
  const influenceScore = Math.min(100,
    (totalMessages * 0.5) +
    (totalThreads * 1.5) +
    (reactionsReceived * 2) +
    (activeChannels * 5)
  );

  return {
    userId,
    userName: user.user.real_name,
    metrics: {
      messageCount: totalMessages,
      threadParticipation: totalThreads,
      reactionsGiven,
      reactionsReceived,
      avgResponseTimeMinutes: 0, // åˆ¥é€”è¨ˆç®—
      channelsActive: activeChannels,
      influenceScore
    }
  };
}

// ãƒãƒ¼ãƒ å…¨ä½“ã®ã‚¤ãƒ³ãƒ•ãƒ«ã‚¨ãƒ³ã‚µãƒ¼è­˜åˆ¥
async function identifyTopInfluencers(
  limit: number = 10
): Promise<UserEngagement[]> {
  const users = await mcp.callTool('slack_list_users', {});
  const engagements: UserEngagement[] = [];

  for (const user of users.members) {
    if (user.is_bot || user.deleted) continue;
    const engagement = await calculateUserEngagement(user.id);
    engagements.push(engagement);
  }

  return engagements
    .sort((a, b) => b.metrics.influenceScore - a.metrics.influenceScore)
    .slice(0, limit);
}
```

## å®Ÿè·µæ´»ç”¨äº‹ä¾‹

### äº‹ä¾‹1: è‡ªå‹•ä¼šè­°è¦ç´„ (Salesforce)

<strong>èƒŒæ™¯:</strong> Salesforceã®ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ãƒªãƒ³ã‚°ãƒãƒ¼ãƒ ã¯ã€æ¯æ—¥è¤‡æ•°ã®ãƒãƒ£ãƒ³ãƒãƒ«ã§æŠ€è¡“çš„ãªè­°è«–ã‚’è¡Œã£ã¦ã„ã¾ã—ãŸãŒã€æƒ…å ±ãŒåˆ†æ•£ã—ã€é‡è¦ãªæ±ºå®šäº‹é …ã‚’è¿½è·¡ã™ã‚‹ã“ã¨ãŒå›°é›£ã§ã—ãŸã€‚

<strong>å®Ÿè£…æ–¹æ³•:</strong>

```typescript
interface MeetingSummary {
  channel: string;
  date: string;
  participants: string[];
  keyDecisions: string[];
  actionItems: Array<{
    task: string;
    assignee: string;
    dueDate: string;
  }>;
  nextSteps: string[];
}

async function generateMeetingSummary(
  channelId: string,
  startTime: string,
  endTime: string
): Promise<MeetingSummary> {
  // ä¼šè­°æ™‚é–“ä¸­ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å–å¾—
  const messages = await mcp.callTool('slack_conversations_history', {
    channel: channelId,
    oldest: startTime,
    latest: endTime
  });

  // å…¨ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’çµåˆ
  const fullConversation = messages.messages
    .map(m => `${m.user}: ${m.text}`)
    .join('\n');

  // Claude AIã§è¦ç´„ç”Ÿæˆ
  const summary = await claude.analyze({
    prompt: `ä»¥ä¸‹ã®Slackä¼šè­°ãƒ­ã‚°ã‚’åˆ†æã—ã€JSONå½¢å¼ã§ã‚µãƒãƒªãƒ¼ã‚’ä½œæˆã—ã¦ãã ã•ã„:

ä¼šè­°ãƒ­ã‚°:
${fullConversation}

ä»¥ä¸‹ã®å½¢å¼ã§è¿”ã—ã¦ãã ã•ã„:
{
  "keyDecisions": ["æ±ºå®šäº‹é …1", "æ±ºå®šäº‹é …2"],
  "actionItems": [
    {"task": "ã‚¿ã‚¹ã‚¯", "assignee": "æ‹…å½“è€…", "dueDate": "æœŸé™"}
  ],
  "nextSteps": ["æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—1", "æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—2"]
}`,
    model: 'claude-3-5-sonnet-20241022'
  });

  const parsed = JSON.parse(summary.content);

  // ã‚µãƒãƒªãƒ¼ã‚’ãƒãƒ£ãƒ³ãƒãƒ«ã«æŠ•ç¨¿
  await mcp.callTool('slack_post_message', {
    channel: channelId,
    blocks: [
      {
        type: 'header',
        text: { type: 'plain_text', text: 'ä¼šè­°ã‚µãƒãƒªãƒ¼' }
      },
      {
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: `*ä¸»è¦æ±ºå®šäº‹é …:*\n${parsed.keyDecisions.map(d => `â€¢ ${d}`).join('\n')}`
        }
      },
      {
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: `*ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚¢ã‚¤ãƒ†ãƒ :*\n${parsed.actionItems.map(a =>
            `â€¢ ${a.task} (@${a.assignee} - ${a.dueDate})`
          ).join('\n')}`
        }
      }
    ]
  });

  return {
    channel: channelId,
    date: new Date().toISOString(),
    participants: [...new Set(messages.messages.map(m => m.user))],
    ...parsed
  };
}
```

<strong>ãƒ“ã‚¸ãƒã‚¹ã‚¤ãƒ³ãƒ‘ã‚¯ãƒˆ:</strong>
- ä¼šè­°å¾Œã®ãƒ•ã‚©ãƒ­ãƒ¼ã‚¢ãƒƒãƒ—æ™‚é–“ãŒ60%å‰Šæ¸›
- ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚¢ã‚¤ãƒ†ãƒ ã®å®Œäº†ç‡ãŒ35%å‘ä¸Š
- æ–°ãƒ¡ãƒ³ãƒãƒ¼ã®ã‚ªãƒ³ãƒœãƒ¼ãƒ‡ã‚£ãƒ³ã‚°æœŸé–“ãŒ2é€±é–“çŸ­ç¸®

### äº‹ä¾‹2: ã‚«ã‚¹ã‚¿ãƒãƒ¼ã‚µãƒãƒ¼ãƒˆã‚¤ãƒ³ã‚µã‚¤ãƒˆ (ã‚¹ã‚¿ãƒ¼ãƒˆã‚¢ãƒƒãƒ—)

<strong>èƒŒæ™¯:</strong> æ€¥æˆé•·ä¸­ã®SaaSã‚¹ã‚¿ãƒ¼ãƒˆã‚¢ãƒƒãƒ—ãŒã€Slack Connectã‚’é€šã˜ã¦é¡§å®¢ã‚µãƒãƒ¼ãƒˆã‚’æä¾›ã—ã¦ã„ã¾ã—ãŸãŒã€å•é¡Œã®åˆ†é¡ã¨å„ªå…ˆé †ä½ä»˜ã‘ãŒæ‰‹å‹•ã§éåŠ¹ç‡ã§ã—ãŸã€‚

<strong>å®Ÿè£…æ–¹æ³•:</strong>

```typescript
interface SupportTicket {
  messageId: string;
  customerId: string;
  category: string;
  priority: 'low' | 'medium' | 'high' | 'critical';
  sentiment: number;
  estimatedResolutionTime: number;
  suggestedResponse?: string;
}

async function analyzeSupport Ticket(
  channelId: string,
  messageTs: string
): Promise<SupportTicket> {
  const message = await fetchMessage(channelId, messageTs);

  // Claude AIã§åˆ†é¡ãƒ»å„ªå…ˆé †ä½ä»˜ã‘
  const analysis = await claude.analyze({
    prompt: `ã‚«ã‚¹ã‚¿ãƒãƒ¼ã‚µãƒãƒ¼ãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’åˆ†æã—ã¦ãã ã•ã„:

ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸: "${message.text}"

ä»¥ä¸‹ã®æƒ…å ±ã‚’JSONå½¢å¼ã§è¿”ã—ã¦ãã ã•ã„:
{
  "category": "technical|billing|feature_request|bug|other",
  "priority": "low|medium|high|critical",
  "sentiment": -1ã‹ã‚‰1ã®ç¯„å›²,
  "estimatedResolutionTimeHours": æ•°å€¤,
  "suggestedResponse": "æ¨å¥¨ã™ã‚‹è¿”ç­”"
}`,
    model: 'claude-3-5-sonnet-20241022'
  });

  const parsed = JSON.parse(analysis.content);

  // é«˜å„ªå…ˆåº¦ã®å ´åˆã€è‡ªå‹•ã‚¨ã‚¹ã‚«ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
  if (parsed.priority === 'critical') {
    await mcp.callTool('slack_post_message', {
      channel: process.env.SUPPORT_ESCALATION_CHANNEL!,
      text: `ğŸš¨ ç·Šæ€¥ã‚µãƒãƒ¼ãƒˆãƒã‚±ãƒƒãƒˆ\né¡§å®¢: ${message.user}\nã‚«ãƒ†ã‚´ãƒª: ${parsed.category}\nãƒ¡ãƒƒã‚»ãƒ¼ã‚¸: ${message.text}`,
      blocks: [
        {
          type: 'section',
          text: {
            type: 'mrkdwn',
            text: `*æ¨å¥¨å¯¾å¿œ:*\n${parsed.suggestedResponse}`
          }
        },
        {
          type: 'actions',
          elements: [
            {
              type: 'button',
              text: { type: 'plain_text', text: 'å¯¾å¿œé–‹å§‹' },
              style: 'primary',
              value: messageTs
            }
          ]
        }
      ]
    });
  }

  return {
    messageId: messageTs,
    customerId: message.user,
    category: parsed.category,
    priority: parsed.priority,
    sentiment: parsed.sentiment,
    estimatedResolutionTime: parsed.estimatedResolutionTimeHours,
    suggestedResponse: parsed.suggestedResponse
  };
}

// å¿œç­”æ™‚é–“æœ€é©åŒ–
async function optimizeResponseTime(): Promise<void> {
  const tickets = await fetchPendingTickets();

  // å„ªå…ˆåº¦ã¨SLAã«åŸºã¥ã„ã¦ã‚½ãƒ¼ãƒˆ
  const sortedTickets = tickets.sort((a, b) => {
    const priorityWeight = { critical: 4, high: 3, medium: 2, low: 1 };
    return priorityWeight[b.priority] - priorityWeight[a.priority];
  });

  // ã‚µãƒãƒ¼ãƒˆãƒãƒ¼ãƒ ã«æœ€é©åŒ–ã•ã‚ŒãŸã‚­ãƒ¥ãƒ¼ã‚’é€šçŸ¥
  await mcp.callTool('slack_post_message', {
    channel: process.env.SUPPORT_TEAM_CHANNEL!,
    text: 'æœ€é©åŒ–ã•ã‚ŒãŸã‚µãƒãƒ¼ãƒˆã‚­ãƒ¥ãƒ¼',
    blocks: sortedTickets.slice(0, 10).map(ticket => ({
      type: 'section',
      text: {
        type: 'mrkdwn',
        text: `*${ticket.priority.toUpperCase()}* - ${ticket.category}\näºˆæƒ³è§£æ±ºæ™‚é–“: ${ticket.estimatedResolutionTime}æ™‚é–“`
      }
    }))
  });
}
```

<strong>ROIæ¸¬å®š:</strong>
- å¹³å‡å¿œç­”æ™‚é–“: 4.2æ™‚é–“ â†’ 1.8æ™‚é–“ (57%æ”¹å–„)
- é¡§å®¢æº€è¶³åº¦: 78% â†’ 91% (13ãƒã‚¤ãƒ³ãƒˆå‘ä¸Š)
- ã‚µãƒãƒ¼ãƒˆãƒãƒ¼ãƒ åŠ¹ç‡: 1äººã‚ãŸã‚Š1æ—¥15ä»¶ â†’ 28ä»¶å¯¾å¿œå¯èƒ½

### äº‹ä¾‹3: ãƒªãƒ¢ãƒ¼ãƒˆãƒãƒ¼ãƒ æ–‡åŒ–ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚° (ã‚°ãƒ­ãƒ¼ãƒãƒ«ä¼æ¥­)

<strong>èƒŒæ™¯:</strong> 1,000äººä»¥ä¸Šã®ãƒªãƒ¢ãƒ¼ãƒˆå¾“æ¥­å“¡ã‚’æŠ±ãˆã‚‹ã‚°ãƒ­ãƒ¼ãƒãƒ«ä¼æ¥­ãŒã€ãƒãƒ¼ãƒ ã®å­¤ç«‹ã‚„ãƒãƒ¼ãƒ³ã‚¢ã‚¦ãƒˆã®ãƒªã‚¹ã‚¯ã‚’æ—©æœŸã«æ¤œå‡ºã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã—ãŸã€‚

<strong>å®Ÿè£…æ–¹æ³•:</strong>

```typescript
interface TeamHealthScore {
  teamId: string;
  teamName: string;
  overallScore: number; // 0ã€œ100
  dimensions: {
    communication: number;
    collaboration: number;
    morale: number;
    engagement: number;
    workload: number;
  };
  risks: Array<{
    type: 'isolation' | 'burnout' | 'low_morale' | 'communication_gap';
    severity: 'low' | 'medium' | 'high';
    affectedUsers: string[];
    recommendation: string;
  }>;
}

async function calculateTeamHealth(
  teamChannelId: string,
  days: number = 30
): Promise<TeamHealthScore> {
  const messages = await fetchRecentMessages(teamChannelId, days);
  const users = await getChannelMembers(teamChannelId);

  // å„æ¬¡å…ƒã®ã‚¹ã‚³ã‚¢è¨ˆç®—
  const communicationScore = calculateCommunicationScore(messages, users);
  const collaborationScore = calculateCollaborationScore(messages);
  const moraleScore = await calculateMoraleScore(messages);
  const engagementScore = calculateEngagementScore(messages, users);
  const workloadScore = calculateWorkloadScore(messages);

  const overallScore = (
    communicationScore +
    collaborationScore +
    moraleScore +
    engagementScore +
    workloadScore
  ) / 5;

  // ãƒªã‚¹ã‚¯æ¤œå‡º
  const risks = [];

  // å­¤ç«‹ãƒªã‚¹ã‚¯æ¤œå‡º
  const isolatedUsers = users.filter(user => {
    const userMessages = messages.filter(m => m.user === user.id);
    return userMessages.length < 5; // 30æ—¥ã§5ä»¶æœªæº€
  });

  if (isolatedUsers.length > 0) {
    risks.push({
      type: 'isolation' as const,
      severity: isolatedUsers.length > users.length * 0.2 ? 'high' : 'medium' as const,
      affectedUsers: isolatedUsers.map(u => u.id),
      recommendation: '1on1ãƒŸãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚’è¨­å®šã—ã€ã‚¨ãƒ³ã‚²ãƒ¼ã‚¸ãƒ¡ãƒ³ãƒˆå‘ä¸Šã®æ–½ç­–ã‚’æ¤œè¨ã—ã¦ãã ã•ã„'
    });
  }

  // ãƒãƒ¼ãƒ³ã‚¢ã‚¦ãƒˆãƒªã‚¹ã‚¯æ¤œå‡º (å¤œé–“ãƒ»é€±æœ«ã®éåº¦ãªæ´»å‹•)
  const burnoutRiskUsers = detectBurnoutRisk(messages, users);
  if (burnoutRiskUsers.length > 0) {
    risks.push({
      type: 'burnout' as const,
      severity: 'high' as const,
      affectedUsers: burnoutRiskUsers,
      recommendation: 'ãƒ¯ãƒ¼ã‚¯ãƒ­ãƒ¼ãƒ‰ã®å†åˆ†é…ã¨ä¼‘æš‡å–å¾—ã‚’ä¿ƒé€²ã—ã¦ãã ã•ã„'
    });
  }

  return {
    teamId: teamChannelId,
    teamName: await getChannelName(teamChannelId),
    overallScore,
    dimensions: {
      communication: communicationScore,
      collaboration: collaborationScore,
      morale: moraleScore,
      engagement: engagementScore,
      workload: workloadScore
    },
    risks
  };
}

function detectBurnoutRisk(messages: any[], users: any[]): string[] {
  const burnoutUsers: string[] = [];

  for (const user of users) {
    const userMessages = messages.filter(m => m.user === user.id);

    let afterHoursCount = 0;
    let weekendCount = 0;

    for (const msg of userMessages) {
      const timestamp = new Date(parseFloat(msg.ts) * 1000);
      const hour = timestamp.getHours();
      const day = timestamp.getDay();

      // å¤œé–“ (22æ™‚ã€œ6æ™‚)
      if (hour >= 22 || hour < 6) afterHoursCount++;

      // é€±æœ«
      if (day === 0 || day === 6) weekendCount++;
    }

    // 30æ—¥é–“ã§å¤œé–“ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸20ä»¶ä»¥ä¸Šã€ã¾ãŸã¯é€±æœ«ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸15ä»¶ä»¥ä¸Š
    if (afterHoursCount > 20 || weekendCount > 15) {
      burnoutUsers.push(user.id);
    }
  }

  return burnoutUsers;
}

// è‡ªå‹•ä»‹å…¥ã‚·ã‚¹ãƒ†ãƒ 
async function autoIntervention(health: TeamHealthScore): Promise<void> {
  for (const risk of health.risks) {
    if (risk.severity === 'high') {
      // ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã«é€šçŸ¥
      await mcp.callTool('slack_post_message', {
        channel: process.env.MANAGER_ALERT_CHANNEL!,
        text: `âš ï¸ ãƒãƒ¼ãƒ å¥å…¨æ€§ã‚¢ãƒ©ãƒ¼ãƒˆ: ${health.teamName}`,
        blocks: [
          {
            type: 'section',
            text: {
              type: 'mrkdwn',
              text: `*ãƒªã‚¹ã‚¯ã‚¿ã‚¤ãƒ—:* ${risk.type}\n*æ·±åˆ»åº¦:* ${risk.severity}\n*å½±éŸ¿ã‚’å—ã‘ã‚‹ãƒ¦ãƒ¼ã‚¶ãƒ¼:* ${risk.affectedUsers.length}å`
            }
          },
          {
            type: 'section',
            text: {
              type: 'mrkdwn',
              text: `*æ¨å¥¨ã‚¢ã‚¯ã‚·ãƒ§ãƒ³:*\n${risk.recommendation}`
            }
          }
        ]
      });

      // è©²å½“ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«å€‹åˆ¥ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ (å­¤ç«‹ãƒªã‚¹ã‚¯ã®å ´åˆ)
      if (risk.type === 'isolation') {
        for (const userId of risk.affectedUsers) {
          await mcp.callTool('slack_post_message', {
            channel: userId,
            text: `ã“ã‚“ã«ã¡ã¯ï¼æœ€è¿‘ãƒãƒ£ãƒ³ãƒãƒ«ã§ã®æ´»å‹•ãŒå°‘ãªã„ã‚ˆã†ã§ã™ãŒã€ä½•ã‹ã‚µãƒãƒ¼ãƒˆã§ãã‚‹ã“ã¨ã¯ã‚ã‚Šã¾ã™ã‹ï¼Ÿæ°—è»½ã«å£°ã‚’ã‹ã‘ã¦ãã ã•ã„ğŸ˜Š`
          });
        }
      }
    }
  }
}
```

<strong>ãƒ“ã‚¸ãƒã‚¹ã‚¤ãƒ³ãƒ‘ã‚¯ãƒˆ:</strong>
- å¾“æ¥­å“¡æº€è¶³åº¦: 72% â†’ 86% (14ãƒã‚¤ãƒ³ãƒˆå‘ä¸Š)
- é›¢è·ç‡: 18% â†’ 9% (50%å‰Šæ¸›)
- æ—©æœŸä»‹å…¥æˆåŠŸç‡: 78% (ãƒªã‚¹ã‚¯æ¤œå‡ºã‹ã‚‰1é€±é–“ä»¥å†…ã®æ”¹å–„)

## å¯èƒ½ãªã“ã¨ã¨ä¸å¯èƒ½ãªã“ã¨

### Slack MCPã§å¯èƒ½ãªã“ã¨

âœ… <strong>ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ‡ãƒ¼ã‚¿å–å¾—ã¨åˆ†æ</strong>
- éå»30æ—¥é–“ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å±¥æ­´ã®å³åº§ã®å–å¾—
- ãƒãƒ£ãƒ³ãƒãƒ«æ¨ªæ–­çš„ãªãƒˆãƒ¬ãƒ³ãƒ‰åˆ†æ
- ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¨ãƒ³ã‚²ãƒ¼ã‚¸ãƒ¡ãƒ³ãƒˆã®ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ¸¬å®š

âœ… <strong>é«˜åº¦ãªè‡ªç„¶è¨€èªå‡¦ç†</strong>
- Claude AIã«ã‚ˆã‚‹æ„Ÿæƒ…åˆ†æ
- ãƒˆãƒ”ãƒƒã‚¯è‡ªå‹•åˆ†é¡
- æ„å›³èªè­˜ã¨ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆç†è§£

âœ… <strong>è‡ªå‹•åŒ–ã¨ã‚ªãƒ¼ã‚±ã‚¹ãƒˆãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³</strong>
- å®šæœŸãƒ¬ãƒãƒ¼ãƒˆã®è‡ªå‹•ç”Ÿæˆ
- ã‚¢ãƒ©ãƒ¼ãƒˆã¨ã‚¨ã‚¹ã‚«ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã®è‡ªå‹•åŒ–
- ã‚¯ãƒ­ã‚¹ãƒãƒ£ãƒ³ãƒãƒ«åˆ†æã¨çµ±åˆ

âœ… <strong>ã‚«ã‚¹ã‚¿ãƒ ã‚¤ãƒ³ã‚µã‚¤ãƒˆç”Ÿæˆ</strong>
- ãƒãƒ¼ãƒ å›ºæœ‰ã®KPIè¨ˆç®—
- æ¥­ç•Œç‰¹åŒ–å‹åˆ†æ
- äºˆæ¸¬ãƒ¢ãƒ‡ãƒªãƒ³ã‚° (ãƒˆãƒ¬ãƒ³ãƒ‰äºˆæ¸¬ã€ãƒªã‚¹ã‚¯äºˆæ¸¬)

âœ… <strong>åŒæ–¹å‘ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³</strong>
- åˆ†æçµæœã®Slackã¸ã®è‡ªå‹•æŠ•ç¨¿
- ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–ãªãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰
- ã‚¹ãƒ¬ãƒƒãƒ‰ã§ã®è©³ç´°æƒ…å ±æä¾›

âœ… <strong>ã‚¨ãƒ³ã‚¿ãƒ¼ãƒ—ãƒ©ã‚¤ã‚ºãƒ¬ãƒ™ãƒ«ã®ã‚¹ã‚±ãƒ¼ãƒ©ãƒ“ãƒªãƒ†ã‚£</strong>
- å¤§è¦æ¨¡ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹å¯¾å¿œ (10,000+ ãƒ¦ãƒ¼ã‚¶ãƒ¼)
- è¤‡æ•°ãƒãƒ¼ãƒ ãƒ»éƒ¨é–€ã®çµ±åˆåˆ†æ
- é•·æœŸãƒ‡ãƒ¼ã‚¿ã®ä¿å­˜ã¨æ™‚ç³»åˆ—åˆ†æ

âœ… <strong>ä»–MCPã‚µãƒ¼ãƒãƒ¼ã¨ã®çµ±åˆ</strong>
- GitHub MCPã¨é€£æºã—ãŸDevOpsåˆ†æ
- Postgres MCPã«ã‚ˆã‚‹æ°¸ç¶šåŒ–
- Google Analytics MCPã¨ã®ã‚¯ãƒ­ã‚¹ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ åˆ†æ

### Slack MCPã§ä¸å¯èƒ½ãªã“ã¨ (ãŠã‚ˆã³ä»£æ›¿æ¡ˆ)

âŒ <strong>ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°</strong>
- <strong>åˆ¶ç´„:</strong> WebSocketæ¥ç¶šã‚„Event APIã®ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã‚¹ãƒˆãƒªãƒ¼ãƒ ã¯ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã›ã‚“
- <strong>ä»£æ›¿æ¡ˆ:</strong> ãƒãƒ¼ãƒªãƒ³ã‚°ãƒ™ãƒ¼ã‚¹ã®ç–‘ä¼¼ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ å®Ÿè£… (5ã€œ30ç§’é–“éš”)
- <strong>å›é¿ç­–:</strong> Socket Modeå¯¾å¿œã®åˆ¥ã‚µãƒ¼ãƒãƒ¼ã¨ä½µç”¨

âŒ <strong>ãƒ•ã‚¡ã‚¤ãƒ«ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®æ·±ã„åˆ†æ</strong>
- <strong>åˆ¶ç´„:</strong> PDFã‚„ç”»åƒå†…ã®ãƒ†ã‚­ã‚¹ãƒˆæŠ½å‡ºã¯ç›´æ¥ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã›ã‚“
- <strong>ä»£æ›¿æ¡ˆ:</strong> Slack APIã§ãƒ•ã‚¡ã‚¤ãƒ«URLã‚’å–å¾—ã—ã€å¤–éƒ¨OCR/PDFãƒ‘ãƒ¼ã‚µãƒ¼ã‚’ä½¿ç”¨
- <strong>å›é¿ç­–:</strong> Claude Visionã§Slackã®ç”»åƒã‚’åˆ†æ (åˆ¥é€”å®Ÿè£…å¿…è¦)

âŒ <strong>ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ç·¨é›†ãƒ»å‰Šé™¤</strong>
- <strong>åˆ¶ç´„:</strong> æ—¢å­˜ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ç·¨é›†ãƒ»å‰Šé™¤æ©Ÿèƒ½ã¯ç¾ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã§ã¯åˆ¶é™ã•ã‚Œã¦ã„ã¾ã™
- <strong>ä»£æ›¿æ¡ˆ:</strong> æ–°ã—ã„ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã§è¨‚æ­£ã‚’æŠ•ç¨¿
- <strong>å›é¿ç­–:</strong> ç›´æ¥Slack APIã‚’ä½¿ç”¨ (chat.updateã€chat.delete)

âŒ <strong>ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼è‡ªå‹•åŒ–ã®ä½œæˆ</strong>
- <strong>åˆ¶ç´„:</strong> Slack Workflow Builderã®ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ä½œæˆã¯ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã›ã‚“
- <strong>ä»£æ›¿æ¡ˆ:</strong> MCPãƒ„ãƒ¼ãƒ«ã®çµ„ã¿åˆã‚ã›ã§åŒç­‰ã®æ©Ÿèƒ½ã‚’å®Ÿè£…
- <strong>å›é¿ç­–:</strong> Slack API + Workflow Builderã§äº‹å‰ä½œæˆ

âŒ <strong>éŸ³å£°ãƒ»ãƒ“ãƒ‡ã‚ªé€šè©±ãƒ‡ãƒ¼ã‚¿ã®åˆ†æ</strong>
- <strong>åˆ¶ç´„:</strong> Slack Huddles ã‚„Clipsã®ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã¯å–å¾—ã§ãã¾ã›ã‚“
- <strong>ä»£æ›¿æ¡ˆ:</strong> ãƒ†ã‚­ã‚¹ãƒˆãƒ™ãƒ¼ã‚¹ã®ä¼šè­°è¦ç´„ã«ç„¦ç‚¹ã‚’å½“ã¦ã‚‹
- <strong>å›é¿ç­–:</strong> ä¼šè­°å¾Œã«ãƒ†ã‚­ã‚¹ãƒˆã‚µãƒãƒªãƒ¼ã‚’æŠ•ç¨¿ã™ã‚‹ãƒ«ãƒ¼ãƒ«ã‚’è¨­å®š

## åˆ¶ç´„äº‹é …ã¨ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹

### Rate Limitç®¡ç†

Slack APIã«ã¯å³æ ¼ãªRate LimitãŒã‚ã‚Šã€é©åˆ‡ãªç®¡ç†ãŒå¿…è¦ã§ã™ã€‚

<strong>ä¸»ãªRate Limit:</strong>

| ãƒ¡ã‚½ãƒƒãƒ‰ | Tier 1 | Tier 2 | Tier 3 | Tier 4 |
|---------|--------|--------|--------|--------|
| <strong>conversations.history</strong> | 50/åˆ† | 50/åˆ† | 50/åˆ† | 100/åˆ† |
| <strong>users.list</strong> | 50/åˆ† | 100/åˆ† | 100/åˆ† | 100/åˆ† |
| <strong>search.messages</strong> | 20/åˆ† | 20/åˆ† | 20/åˆ† | 20/åˆ† |
| <strong>chat.postMessage</strong> | 1/ç§’ | 1/ç§’ | 1/ç§’ | 1/ç§’ |

<strong>ãƒãƒƒãƒå‡¦ç†æˆ¦ç•¥:</strong>

```typescript
class RateLimitedSlackClient {
  private requestQueue: Array<() => Promise<any>> = [];
  private processing = false;
  private lastRequestTime = 0;
  private minInterval = 1000; // 1ç§’

  async callTool(toolName: string, params: any): Promise<any> {
    return new Promise((resolve, reject) => {
      this.requestQueue.push(async () => {
        try {
          // Rate limitéµå®ˆ
          const now = Date.now();
          const timeSinceLastRequest = now - this.lastRequestTime;
          if (timeSinceLastRequest < this.minInterval) {
            await sleep(this.minInterval - timeSinceLastRequest);
          }

          const result = await mcp.callTool(toolName, params);
          this.lastRequestTime = Date.now();
          resolve(result);
        } catch (error) {
          if (error.message.includes('rate_limited')) {
            // å†è©¦è¡Œãƒ­ã‚¸ãƒƒã‚¯
            console.log('Rate limit detected, retrying after delay...');
            await sleep(60000); // 1åˆ†å¾…æ©Ÿ
            this.requestQueue.unshift(async () => resolve(await this.callTool(toolName, params)));
          } else {
            reject(error);
          }
        }
      });

      if (!this.processing) {
        this.processQueue();
      }
    });
  }

  private async processQueue(): Promise<void> {
    this.processing = true;

    while (this.requestQueue.length > 0) {
      const request = this.requestQueue.shift()!;
      await request();
    }

    this.processing = false;
  }
}

function sleep(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms));
}
```

<strong>ã‚­ãƒ£ãƒƒã‚·ãƒ³ã‚°å®Ÿè£…:</strong>

```typescript
interface CacheEntry<T> {
  data: T;
  timestamp: number;
  ttl: number;
}

class SlackDataCache {
  private cache = new Map<string, CacheEntry<any>>();

  get<T>(key: string): T | null {
    const entry = this.cache.get(key);
    if (!entry) return null;

    const age = Date.now() - entry.timestamp;
    if (age > entry.ttl) {
      this.cache.delete(key);
      return null;
    }

    return entry.data as T;
  }

  set<T>(key: string, data: T, ttlSeconds: number = 300): void {
    this.cache.set(key, {
      data,
      timestamp: Date.now(),
      ttl: ttlSeconds * 1000
    });
  }

  // ä½¿ç”¨ä¾‹
  async getCachedChannels(): Promise<any[]> {
    const cacheKey = 'channels_list';
    const cached = this.get<any[]>(cacheKey);

    if (cached) {
      console.log('Using cached channel list');
      return cached;
    }

    const channels = await mcp.callTool('slack_list_channels', {});
    this.set(cacheKey, channels.channels, 600); // 10åˆ†ã‚­ãƒ£ãƒƒã‚·ãƒ¥
    return channels.channels;
  }
}
```

### ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è€ƒæ…®äº‹é …

<strong>APIã‚­ãƒ¼ç®¡ç†ã®ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹:</strong>

```typescript
// âŒ æ‚ªã„ä¾‹: ãƒãƒ¼ãƒ‰ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°
const SLACK_TOKEN = 'xoxb-123456789-abcdefghijk';

// âœ… è‰¯ã„ä¾‹: ç’°å¢ƒå¤‰æ•°
const SLACK_TOKEN = process.env.SLACK_BOT_TOKEN;
if (!SLACK_TOKEN) {
  throw new Error('SLACK_BOT_TOKEN environment variable is required');
}

// âœ… ã•ã‚‰ã«è‰¯ã„ä¾‹: ã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆç®¡ç†ã‚µãƒ¼ãƒ“ã‚¹
import { SecretsManager } from 'aws-sdk';

async function getSlackToken(): Promise<string> {
  const secretsManager = new SecretsManager();
  const secret = await secretsManager.getSecretValue({
    SecretId: 'prod/slack/bot-token'
  }).promise();

  return JSON.parse(secret.SecretString!).token;
}
```

<strong>æœ€å°æ¨©é™åŸå‰‡:</strong>

```typescript
// ãƒãƒ£ãƒ³ãƒãƒ«åˆ†æç”¨ã®æœ€å°ã‚¹ã‚³ãƒ¼ãƒ—
const REQUIRED_SCOPES = [
  'channels:history',  // ãƒ‘ãƒ–ãƒªãƒƒã‚¯ãƒãƒ£ãƒ³ãƒãƒ«å±¥æ­´ã®ã¿
  'channels:read',     // ãƒãƒ£ãƒ³ãƒãƒ«æƒ…å ±ã®ã¿
  'users:read'         // ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã®ã¿
];

// âŒ éå‰°ãªæ¨©é™
const EXCESSIVE_SCOPES = [
  'channels:write',    // ä¸è¦: èª­å–å°‚ç”¨åˆ†æã«ã¯ä¸è¦
  'users:write',       // ä¸è¦: ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã®å¤‰æ›´ã¯ä¸è¦
  'admin'              // å±é™º: ç®¡ç†è€…æ¨©é™ã¯çµ¶å¯¾ã«é¿ã‘ã‚‹
];
```

<strong>PII (å€‹äººè­˜åˆ¥æƒ…å ±) ãƒ‡ãƒ¼ã‚¿ä¿è­·:</strong>

```typescript
interface SafeUserData {
  userId: string;          // âœ… OK: å†…éƒ¨ID
  userName: string;        // âœ… OK: è¡¨ç¤ºå
  // email: string;        // âŒ é™¤å¤–: ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹
  // phoneNumber: string;  // âŒ é™¤å¤–: é›»è©±ç•ªå·
  messageCount: number;    // âœ… OK: é›†è¨ˆãƒ‡ãƒ¼ã‚¿
}

function sanitizeUserData(user: any): SafeUserData {
  return {
    userId: user.id,
    userName: user.name,
    messageCount: 0  // å¾Œã§è¨ˆç®—
  };
}

// ãƒ‡ãƒ¼ã‚¿ä¿å­˜æ™‚ã®åŒ¿ååŒ–
function anonymizeForStorage(data: any): any {
  return {
    ...data,
    userId: hashUserId(data.userId),  // ãƒãƒƒã‚·ãƒ¥åŒ–
    messageText: redactPII(data.messageText)  // PIIé™¤å»
  };
}
```

### ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–

<strong>ãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³æˆ¦ç•¥:</strong>

```typescript
async function fetchAllMessages(
  channelId: string,
  days: number = 30
): Promise<any[]> {
  const allMessages: any[] = [];
  let cursor: string | undefined;
  const oldest = (Date.now() / 1000) - (days * 24 * 60 * 60);

  do {
    const response = await mcp.callTool('slack_conversations_history', {
      channel: channelId,
      oldest: oldest.toString(),
      limit: 200,  // æœ€å¤§å€¤
      cursor
    });

    allMessages.push(...response.messages);
    cursor = response.response_metadata?.next_cursor;

    // Rate limitå›é¿ã®ãŸã‚ã®é…å»¶
    if (cursor) {
      await sleep(1000);
    }
  } while (cursor);

  return allMessages;
}
```

<strong>ä¸¦åˆ—å‡¦ç†:</strong>

```typescript
async function analyzeMultipleChannels(
  channelIds: string[]
): Promise<Map<string, any>> {
  const results = new Map<string, any>();

  // ãƒãƒ£ãƒ³ã‚¯å‡¦ç† (åŒæ™‚5ãƒãƒ£ãƒ³ãƒãƒ«ã¾ã§)
  const chunkSize = 5;
  for (let i = 0; i < channelIds.length; i += chunkSize) {
    const chunk = channelIds.slice(i, i + chunkSize);

    const chunkResults = await Promise.all(
      chunk.map(async channelId => {
        try {
          const analysis = await analyzeChannel(channelId);
          return { channelId, analysis };
        } catch (error) {
          console.error(`Error analyzing ${channelId}:`, error);
          return { channelId, analysis: null };
        }
      })
    );

    for (const { channelId, analysis } of chunkResults) {
      if (analysis) {
        results.set(channelId, analysis);
      }
    }

    // ãƒãƒ£ãƒ³ã‚¯é–“ã®é…å»¶
    if (i + chunkSize < channelIds.length) {
      await sleep(2000);
    }
  }

  return results;
}
```

<strong>ã‚¹ãƒãƒ¼ãƒˆãƒ‡ãƒ¼ã‚¿ãƒ•ã‚§ãƒƒãƒãƒ³ã‚°:</strong>

```typescript
// å¢—åˆ†æ›´æ–°æˆ¦ç•¥
interface ChannelState {
  channelId: string;
  lastFetchTimestamp: number;
  latestMessageTs: string;
}

class IncrementalFetcher {
  private states = new Map<string, ChannelState>();

  async fetchNewMessages(channelId: string): Promise<any[]> {
    const state = this.states.get(channelId);

    const params: any = {
      channel: channelId,
      limit: 100
    };

    // å‰å›å–å¾—ä»¥é™ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ã¿å–å¾—
    if (state) {
      params.oldest = state.latestMessageTs;
    }

    const response = await mcp.callTool('slack_conversations_history', params);

    if (response.messages.length > 0) {
      this.states.set(channelId, {
        channelId,
        lastFetchTimestamp: Date.now(),
        latestMessageTs: response.messages[0].ts
      });
    }

    return response.messages;
  }
}
```

### ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼ä¿è­·ã¨ã‚³ãƒ³ãƒ—ãƒ©ã‚¤ã‚¢ãƒ³ã‚¹

<strong>GDPRæº–æ‹ :</strong>

```typescript
interface GDPRCompliantAnalytics {
  // å€‹äººãƒ‡ãƒ¼ã‚¿ã®æœ€å°åŒ–
  aggregateOnly: boolean;

  // ãƒ‡ãƒ¼ã‚¿ä¿æŒæœŸé–“
  retentionDays: number;

  // ãƒ¦ãƒ¼ã‚¶ãƒ¼åŒæ„ç®¡ç†
  consentRequired: boolean;
  consentedUsers: Set<string>;
}

class GDPRCompliantSlackAnalyzer {
  private config: GDPRCompliantAnalytics;

  constructor(config: GDPRCompliantAnalytics) {
    this.config = config;
  }

  async analyzeWithConsent(channelId: string): Promise<any> {
    const messages = await fetchAllMessages(channelId, this.config.retentionDays);

    // åŒæ„æ¸ˆã¿ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ã¿åˆ†æ
    const consentedMessages = messages.filter(msg =>
      this.config.consentedUsers.has(msg.user)
    );

    // é›†è¨ˆãƒ‡ãƒ¼ã‚¿ã®ã¿è¿”ã™ (å€‹åˆ¥ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¯è¿”ã•ãªã„)
    if (this.config.aggregateOnly) {
      return {
        totalMessages: consentedMessages.length,
        uniqueUsers: new Set(consentedMessages.map(m => m.user)).size,
        avgMessageLength: consentedMessages.reduce((sum, m) =>
          sum + m.text.length, 0) / consentedMessages.length
      };
    }

    return consentedMessages;
  }

  // ãƒ‡ãƒ¼ã‚¿å‰Šé™¤è¦æ±‚å¯¾å¿œ
  async handleDeletionRequest(userId: string): Promise<void> {
    // ãƒ­ãƒ¼ã‚«ãƒ«ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‹ã‚‰å‰Šé™¤
    this.clearUserData(userId);

    // åˆ†æçµæœã‹ã‚‰é™¤å¤–
    this.config.consentedUsers.delete(userId);

    console.log(`User ${userId} data deleted as per GDPR request`);
  }
}
```

<strong>ç›£æŸ»ãƒ­ã‚°:</strong>

```typescript
interface AuditLogEntry {
  timestamp: string;
  action: string;
  userId: string;
  channelId?: string;
  dataAccessed: string[];
  purpose: string;
}

class AuditLogger {
  private logs: AuditLogEntry[] = [];

  log(entry: Omit<AuditLogEntry, 'timestamp'>): void {
    this.logs.push({
      ...entry,
      timestamp: new Date().toISOString()
    });
  }

  async exportLogs(format: 'json' | 'csv'): Promise<string> {
    if (format === 'json') {
      return JSON.stringify(this.logs, null, 2);
    }

    // CSVå½¢å¼ã§ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
    const headers = Object.keys(this.logs[0]).join(',');
    const rows = this.logs.map(log =>
      Object.values(log).map(v => `"${v}"`).join(',')
    );

    return [headers, ...rows].join('\n');
  }
}

// ä½¿ç”¨ä¾‹
const auditLogger = new AuditLogger();

async function analyzeWithAudit(channelId: string, userId: string): Promise<any> {
  auditLogger.log({
    action: 'analyze_channel',
    userId,
    channelId,
    dataAccessed: ['messages', 'reactions', 'users'],
    purpose: 'Team engagement analysis'
  });

  return await analyzeChannel(channelId);
}
```

<strong>ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹é€æ˜æ€§:</strong>

```markdown
# Slackåˆ†æãƒ„ãƒ¼ãƒ«ä½¿ç”¨ãƒãƒªã‚·ãƒ¼

## ãƒ‡ãƒ¼ã‚¿åé›†ç¯„å›²
- ãƒ‘ãƒ–ãƒªãƒƒã‚¯ãƒãƒ£ãƒ³ãƒãƒ«ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å±¥æ­´ (éå»30æ—¥é–“)
- ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ã‚¨ãƒ³ã‚²ãƒ¼ã‚¸ãƒ¡ãƒ³ãƒˆæŒ‡æ¨™ (é›†è¨ˆãƒ‡ãƒ¼ã‚¿ã®ã¿)
- çµµæ–‡å­—ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒ‘ã‚¿ãƒ¼ãƒ³

## é™¤å¤–ãƒ‡ãƒ¼ã‚¿
- ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ (DM)
- å€‹äººãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹
- æ©Ÿå¯†ãƒãƒ£ãƒ³ãƒãƒ« (#confidential-*, #legal-*)

## ç”¨é€”
- ãƒãƒ¼ãƒ ã‚³ãƒŸãƒ¥ãƒ‹ã‚±ãƒ¼ã‚·ãƒ§ãƒ³æ”¹å–„
- ãƒªãƒ¢ãƒ¼ãƒˆãƒ¯ãƒ¼ã‚¯æ–‡åŒ–ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°
- æ¥­å‹™åŠ¹ç‡åŒ–ã®æ´å¯Ÿ

## ãƒ‡ãƒ¼ã‚¿ä¿æŒ
- ç”Ÿãƒ‡ãƒ¼ã‚¿: 30æ—¥å¾Œè‡ªå‹•å‰Šé™¤
- é›†è¨ˆãƒ¬ãƒãƒ¼ãƒˆ: 90æ—¥é–“ä¿æŒ

## ãƒ¦ãƒ¼ã‚¶ãƒ¼æ¨©åˆ©
- ã„ã¤ã§ã‚‚ã‚ªãƒ—ãƒˆã‚¢ã‚¦ãƒˆå¯èƒ½
- ãƒ‡ãƒ¼ã‚¿å‰Šé™¤è¦æ±‚å¯¾å¿œ (72æ™‚é–“ä»¥å†…)
```

## é«˜åº¦ãªæ©Ÿèƒ½

### è¤‡æ•°MCPçµ±åˆ

è¤‡æ•°ã®MCPã‚µãƒ¼ãƒãƒ¼ã‚’çµ„ã¿åˆã‚ã›ã‚‹ã“ã¨ã§ã€ã‚ˆã‚Šå¼·åŠ›ãªåˆ†æãŒå¯èƒ½ã«ãªã‚Šã¾ã™ã€‚

<strong>Slack + GitHub + Postgresçµ±åˆä¾‹:</strong>

```typescript
interface DevOpsInsight {
  slackData: {
    engineeringChannelActivity: number;
    incidentDiscussions: number;
  };
  githubData: {
    commits: number;
    pullRequests: number;
    deployments: number;
  };
  correlations: {
    commitsToSlackActivity: number;
    deploymentsToIncidents: number;
  };
}

async function generateDevOpsInsights(
  days: number = 7
): Promise<DevOpsInsight> {
  // Slack ãƒ‡ãƒ¼ã‚¿å–å¾—
  const slackMessages = await mcp.callTool('slack_conversations_history', {
    channel: process.env.ENGINEERING_CHANNEL!,
    oldest: ((Date.now() / 1000) - (days * 24 * 60 * 60)).toString()
  });

  const incidentMessages = slackMessages.messages.filter(m =>
    m.text.toLowerCase().includes('incident') ||
    m.text.toLowerCase().includes('outage')
  );

  // GitHub ãƒ‡ãƒ¼ã‚¿å–å¾— (GitHub MCPä½¿ç”¨)
  const githubCommits = await mcp.callTool('github_list_commits', {
    repo: 'myorg/myrepo',
    since: new Date(Date.now() - (days * 24 * 60 * 60 * 1000)).toISOString()
  });

  const githubPRs = await mcp.callTool('github_list_pull_requests', {
    repo: 'myorg/myrepo',
    state: 'closed',
    since: new Date(Date.now() - (days * 24 * 60 * 60 * 1000)).toISOString()
  });

  // Postgres ã«ä¿å­˜ (Postgres MCPä½¿ç”¨)
  await mcp.callTool('postgres_execute', {
    query: `
      INSERT INTO devops_metrics (date, slack_activity, github_commits, incidents)
      VALUES ($1, $2, $3, $4)
    `,
    params: [
      new Date().toISOString(),
      slackMessages.messages.length,
      githubCommits.length,
      incidentMessages.length
    ]
  });

  // ç›¸é–¢åˆ†æ
  const commitsToSlackCorrelation = calculateCorrelation(
    githubCommits.length,
    slackMessages.messages.length
  );

  return {
    slackData: {
      engineeringChannelActivity: slackMessages.messages.length,
      incidentDiscussions: incidentMessages.length
    },
    githubData: {
      commits: githubCommits.length,
      pullRequests: githubPRs.length,
      deployments: 0 // åˆ¥é€”å–å¾—
    },
    correlations: {
      commitsToSlackActivity: commitsToSlackCorrelation,
      deploymentsToIncidents: 0 // è¨ˆç®—
    }
  };
}
```

<strong>è‡ªå‹•åŒ–ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼:</strong>

```typescript
// æ¯é€±æœˆæ›œæ—¥9æ™‚ã«å®Ÿè¡Œ
cron.schedule('0 9 * * 1', async () => {
  console.log('Generating weekly DevOps report...');

  const insights = await generateDevOpsInsights(7);

  // Slack ã«æŠ•ç¨¿
  await mcp.callTool('slack_post_message', {
    channel: process.env.DEVOPS_CHANNEL!,
    blocks: [
      {
        type: 'header',
        text: { type: 'plain_text', text: 'é€±æ¬¡DevOpsãƒ¬ãƒãƒ¼ãƒˆ' }
      },
      {
        type: 'section',
        fields: [
          {
            type: 'mrkdwn',
            text: `*Slackæ´»å‹•:*\n${insights.slackData.engineeringChannelActivity}ä»¶`
          },
          {
            type: 'mrkdwn',
            text: `*GitHub Commits:*\n${insights.githubData.commits}ä»¶`
          },
          {
            type: 'mrkdwn',
            text: `*ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆ:*\n${insights.slackData.incidentDiscussions}ä»¶`
          },
          {
            type: 'mrkdwn',
            text: `*Pull Requests:*\n${insights.githubData.pullRequests}ä»¶`
          }
        ]
      },
      {
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: `*ç›¸é–¢åˆ†æ:*\nCommits â†” Slackæ´»å‹•: ${(insights.correlations.commitsToSlackActivity * 100).toFixed(1)}%`
        }
      }
    ]
  });
});
```

<strong>ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ DevOpsé€šçŸ¥:</strong>

```typescript
// GitHub ãƒ‡ãƒ—ãƒ­ã‚¤æ¤œå‡º â†’ Slacké€šçŸ¥
async function monitorDeployments(): Promise<void> {
  const latestDeployment = await mcp.callTool('github_get_latest_deployment', {
    repo: 'myorg/myrepo'
  });

  if (latestDeployment.state === 'success') {
    // ãƒ‡ãƒ—ãƒ­ã‚¤æˆåŠŸã‚’ Slack ã«é€šçŸ¥
    await mcp.callTool('slack_post_message', {
      channel: process.env.ENGINEERING_CHANNEL!,
      text: `âœ… ãƒ‡ãƒ—ãƒ­ã‚¤æˆåŠŸ: ${latestDeployment.environment}`,
      blocks: [
        {
          type: 'section',
          text: {
            type: 'mrkdwn',
            text: `*ãƒ‡ãƒ—ãƒ­ã‚¤å®Œäº†*\nç’°å¢ƒ: ${latestDeployment.environment}\nã‚³ãƒŸãƒƒãƒˆ: ${latestDeployment.sha.substring(0, 7)}\nãƒ‡ãƒ—ãƒ­ã‚¤è€…: ${latestDeployment.creator}`
          }
        },
        {
          type: 'actions',
          elements: [
            {
              type: 'button',
              text: { type: 'plain_text', text: 'GitHub ã§ç¢ºèª' },
              url: latestDeployment.url
            }
          ]
        }
      ]
    });

    // ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³è¿½åŠ ã§ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°é–‹å§‹
    await mcp.callTool('slack_add_reaction', {
      channel: process.env.ENGINEERING_CHANNEL!,
      timestamp: latestDeployment.slackMessageTs,
      name: 'eyes'
    });
  } else if (latestDeployment.state === 'failure') {
    // ãƒ‡ãƒ—ãƒ­ã‚¤å¤±æ•—ã‚¢ãƒ©ãƒ¼ãƒˆ
    await mcp.callTool('slack_post_message', {
      channel: process.env.INCIDENT_CHANNEL!,
      text: `ğŸš¨ ãƒ‡ãƒ—ãƒ­ã‚¤å¤±æ•—: ${latestDeployment.environment}`,
      blocks: [
        {
          type: 'section',
          text: {
            type: 'mrkdwn',
            text: `*ãƒ‡ãƒ—ãƒ­ã‚¤å¤±æ•— - å³åº§ã®å¯¾å¿œãŒå¿…è¦*\nç’°å¢ƒ: ${latestDeployment.environment}\nã‚¨ãƒ©ãƒ¼: ${latestDeployment.error}`
          }
        }
      ]
    });
  }
}
```

### AIé§†å‹•ã‚¤ãƒ³ã‚µã‚¤ãƒˆç”Ÿæˆ

<strong>é€±æ¬¡ãƒ¬ãƒãƒ¼ãƒˆè‡ªå‹•åŒ–:</strong>

```typescript
interface WeeklyReport {
  period: { start: string; end: string };
  summary: string;
  keyMetrics: {
    totalMessages: number;
    activeUsers: number;
    topChannels: Array<{ name: string; activity: number }>;
    sentimentTrend: number;
  };
  highlights: string[];
  concerns: string[];
  recommendations: string[];
}

async function generateWeeklyReport(): Promise<WeeklyReport> {
  const startDate = new Date();
  startDate.setDate(startDate.getDate() - 7);
  const endDate = new Date();

  // å…¨ãƒãƒ£ãƒ³ãƒãƒ«ã®ãƒ‡ãƒ¼ã‚¿åé›†
  const channels = await mcp.callTool('slack_list_channels', {});
  const allMessages: any[] = [];
  const channelActivity = new Map<string, number>();

  for (const channel of channels.channels) {
    const messages = await fetchRecentMessages(channel.id, 7);
    allMessages.push(...messages);
    channelActivity.set(channel.name, messages.length);
  }

  // æ„Ÿæƒ…åˆ†æ
  const sentiments = await analyzeSentiment(allMessages);
  const avgSentiment = sentiments.reduce((sum, s) => sum + s.score, 0) / sentiments.length;

  // Claude AIã§åŒ…æ‹¬çš„ãªã‚µãƒãƒªãƒ¼ç”Ÿæˆ
  const aiSummary = await claude.analyze({
    prompt: `ä»¥ä¸‹ã®Slackãƒ‡ãƒ¼ã‚¿ã‹ã‚‰é€±æ¬¡ãƒ¬ãƒãƒ¼ãƒˆã‚’ç”Ÿæˆã—ã¦ãã ã•ã„:

æœŸé–“: ${startDate.toISOString()} ã€œ ${endDate.toISOString()}
ç·ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æ•°: ${allMessages.length}
ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ¦ãƒ¼ã‚¶ãƒ¼æ•°: ${new Set(allMessages.map(m => m.user)).size}
å¹³å‡æ„Ÿæƒ…ã‚¹ã‚³ã‚¢: ${avgSentiment.toFixed(2)}

ãƒˆãƒƒãƒ—ãƒãƒ£ãƒ³ãƒãƒ«:
${Array.from(channelActivity.entries())
  .sort((a, b) => b[1] - a[1])
  .slice(0, 5)
  .map(([name, count]) => `- #${name}: ${count}ä»¶`)
  .join('\n')}

ä»¥ä¸‹ã®å½¢å¼ã§JSONã‚’è¿”ã—ã¦ãã ã•ã„:
{
  "summary": "ä»Šé€±ã®ç·æ‹¬ (2-3æ–‡)",
  "highlights": ["ãƒã‚¤ãƒ©ã‚¤ãƒˆ1", "ãƒã‚¤ãƒ©ã‚¤ãƒˆ2", "ãƒã‚¤ãƒ©ã‚¤ãƒˆ3"],
  "concerns": ["æ‡¸å¿µäº‹é …1", "æ‡¸å¿µäº‹é …2"],
  "recommendations": ["æ¨å¥¨ã‚¢ã‚¯ã‚·ãƒ§ãƒ³1", "æ¨å¥¨ã‚¢ã‚¯ã‚·ãƒ§ãƒ³2"]
}`,
    model: 'claude-3-5-sonnet-20241022'
  });

  const parsed = JSON.parse(aiSummary.content);

  return {
    period: {
      start: startDate.toISOString(),
      end: endDate.toISOString()
    },
    summary: parsed.summary,
    keyMetrics: {
      totalMessages: allMessages.length,
      activeUsers: new Set(allMessages.map(m => m.user)).size,
      topChannels: Array.from(channelActivity.entries())
        .sort((a, b) => b[1] - a[1])
        .slice(0, 5)
        .map(([name, activity]) => ({ name, activity })),
      sentimentTrend: avgSentiment
    },
    highlights: parsed.highlights,
    concerns: parsed.concerns,
    recommendations: parsed.recommendations
  };
}

// Slack ã«æŠ•ç¨¿
async function publishWeeklyReport(report: WeeklyReport): Promise<void> {
  await mcp.callTool('slack_post_message', {
    channel: process.env.WEEKLY_REPORT_CHANNEL!,
    blocks: [
      {
        type: 'header',
        text: { type: 'plain_text', text: 'é€±æ¬¡ã‚³ãƒŸãƒ¥ãƒ‹ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãƒ¬ãƒãƒ¼ãƒˆ' }
      },
      {
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: `*æœŸé–“:* ${new Date(report.period.start).toLocaleDateString('ja-JP')} ã€œ ${new Date(report.period.end).toLocaleDateString('ja-JP')}\n\n${report.summary}`
        }
      },
      {
        type: 'section',
        fields: report.keyMetrics.topChannels.map(ch => ({
          type: 'mrkdwn',
          text: `*#${ch.name}*\n${ch.activity}ä»¶`
        }))
      },
      {
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: `*ãƒã‚¤ãƒ©ã‚¤ãƒˆ:*\n${report.highlights.map(h => `â€¢ ${h}`).join('\n')}`
        }
      },
      {
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: `*æ‡¸å¿µäº‹é …:*\n${report.concerns.map(c => `âš ï¸ ${c}`).join('\n')}`
        }
      },
      {
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: `*æ¨å¥¨ã‚¢ã‚¯ã‚·ãƒ§ãƒ³:*\n${report.recommendations.map((r, i) => `${i+1}. ${r}`).join('\n')}`
        }
      }
    ]
  });
}
```

<strong>ãƒˆãƒ¬ãƒ³ãƒ‰äºˆæ¸¬:</strong>

```typescript
async function predictEngagementTrend(
  channelId: string,
  historicalDays: number = 90,
  forecastDays: number = 30
): Promise<any> {
  // éå»90æ—¥é–“ã®ãƒ‡ãƒ¼ã‚¿å–å¾—
  const historicalData = await fetchHistoricalEngagement(channelId, historicalDays);

  // Claude AIã§ãƒˆãƒ¬ãƒ³ãƒ‰åˆ†æ
  const prediction = await claude.analyze({
    prompt: `éå»90æ—¥é–“ã®Slackã‚¨ãƒ³ã‚²ãƒ¼ã‚¸ãƒ¡ãƒ³ãƒˆãƒ‡ãƒ¼ã‚¿ã‚’åˆ†æã—ã€ä»Šå¾Œ30æ—¥é–“ã®ãƒˆãƒ¬ãƒ³ãƒ‰ã‚’äºˆæ¸¬ã—ã¦ãã ã•ã„:

${JSON.stringify(historicalData, null, 2)}

ä»¥ä¸‹ã®æƒ…å ±ã‚’JSONå½¢å¼ã§è¿”ã—ã¦ãã ã•ã„:
{
  "trend": "increasing|stable|decreasing",
  "confidence": 0.0-1.0,
  "predictedDailyAverage": æ•°å€¤,
  "seasonalPatterns": ["ãƒ‘ã‚¿ãƒ¼ãƒ³1", "ãƒ‘ã‚¿ãƒ¼ãƒ³2"],
  "riskFactors": ["ãƒªã‚¹ã‚¯1", "ãƒªã‚¹ã‚¯2"],
  "opportunities": ["æ©Ÿä¼š1", "æ©Ÿä¼š2"]
}`,
    model: 'claude-3-5-sonnet-20241022'
  });

  return JSON.parse(prediction.content);
}
```

<strong>ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚¢ã‚¤ãƒ†ãƒ æŠ½å‡º:</strong>

```typescript
async function extractActionItems(
  channelId: string,
  days: number = 7
): Promise<Array<{
  task: string;
  assignee?: string;
  dueDate?: string;
  priority: string;
  source: string;
}>> {
  const messages = await fetchRecentMessages(channelId, days);

  const actionItems = [];

  for (const msg of messages) {
    // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚¢ã‚¤ãƒ†ãƒ ã®å¯èƒ½æ€§ãŒé«˜ã„ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æ¤œå‡º
    if (
      msg.text.includes('TODO') ||
      msg.text.includes('ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚¢ã‚¤ãƒ†ãƒ ') ||
      msg.text.includes('æ‹…å½“:') ||
      msg.text.includes('æœŸé™:')
    ) {
      // Claude AIã§æ§‹é€ åŒ–
      const structured = await claude.analyze({
        prompt: `ä»¥ä¸‹ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‹ã‚‰ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚¢ã‚¤ãƒ†ãƒ ã‚’æŠ½å‡ºã—ã¦ãã ã•ã„:

"${msg.text}"

JSONå½¢å¼ã§è¿”ã—ã¦ãã ã•ã„:
{
  "task": "å…·ä½“çš„ãªã‚¿ã‚¹ã‚¯",
  "assignee": "æ‹…å½“è€…å (ä¸æ˜ãªå ´åˆnull)",
  "dueDate": "æœŸé™ (YYYY-MM-DDå½¢å¼ã€ä¸æ˜ãªå ´åˆnull)",
  "priority": "high|medium|low"
}`,
        model: 'claude-3-5-sonnet-20241022'
      });

      const parsed = JSON.parse(structured.content);
      actionItems.push({
        ...parsed,
        source: msg.permalink
      });
    }
  }

  return actionItems;
}
```

## çµè«–

Slack MCPã¯ã€ãƒãƒ¼ãƒ ã‚³ãƒŸãƒ¥ãƒ‹ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãƒ‡ãƒ¼ã‚¿ã‚’æ´»ç”¨ã™ã‚‹ãŸã‚ã®å¼·åŠ›ãªãƒ„ãƒ¼ãƒ«ã§ã™ã€‚ã“ã®è¨˜äº‹ã§ç´¹ä»‹ã—ãŸæŠ€è¡“ã¨æ‰‹æ³•ã«ã‚ˆã‚Šã€ä»¥ä¸‹ãŒå¯èƒ½ã«ãªã‚Šã¾ã™:

<strong>ä¸»è¦ãªä¾¡å€¤ææ¡ˆ:</strong>

1. <strong>ãƒ‡ãƒ¼ã‚¿é§†å‹•ã®æ„æ€æ±ºå®š</strong>: å®¢è¦³çš„ãªæŒ‡æ¨™ã«åŸºã¥ããƒãƒ¼ãƒ ãƒãƒã‚¸ãƒ¡ãƒ³ãƒˆ
2. <strong>æ—©æœŸå•é¡Œæ¤œå‡º</strong>: ãƒãƒ¼ãƒ³ã‚¢ã‚¦ãƒˆã‚„å­¤ç«‹ã®ãƒªã‚¹ã‚¯ã‚’äº‹å‰ã«è­˜åˆ¥
3. <strong>è‡ªå‹•åŒ–ã«ã‚ˆã‚‹åŠ¹ç‡åŒ–</strong>: ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆã‚„ã‚¢ãƒ©ãƒ¼ãƒˆã®æ‰‹å‹•ä½œæ¥­ã‚’å‰Šæ¸›
4. <strong>AIã«ã‚ˆã‚‹æ·±ã„æ´å¯Ÿ</strong>: Claude AIã®è‡ªç„¶è¨€èªå‡¦ç†ã§éš ã‚ŒãŸãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ç™ºè¦‹
5. <strong>ã‚¹ã‚±ãƒ¼ãƒ©ãƒ“ãƒªãƒ†ã‚£</strong>: å°è¦æ¨¡ãƒãƒ¼ãƒ ã‹ã‚‰å¤§ä¼æ¥­ã¾ã§å¯¾å¿œå¯èƒ½

<strong>å§‹ã‚ã‚‹ãŸã‚ã®ã‚¹ãƒ†ãƒƒãƒ—ãƒã‚¤ã‚¹ãƒ†ãƒƒãƒ—ã‚¬ã‚¤ãƒ‰:</strong>

**ã‚¹ãƒ†ãƒƒãƒ—1: ç’°å¢ƒæº–å‚™ (æ‰€è¦æ™‚é–“: 30åˆ†)**
1. Node.js 18+ ã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
2. Slack App ã‚’ä½œæˆã—ã€Bot Token ã‚’å–å¾—
3. å…¬å¼TypeScript ã‚µãƒ¼ãƒãƒ¼ã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«

**ã‚¹ãƒ†ãƒƒãƒ—2: åŸºæœ¬åˆ†æã®å®Ÿè£… (æ‰€è¦æ™‚é–“: 2æ™‚é–“)**
1. ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒœãƒªãƒ¥ãƒ¼ãƒ åˆ†æã‹ã‚‰é–‹å§‹
2. ãƒãƒ£ãƒ³ãƒãƒ«ã‚¨ãƒ³ã‚²ãƒ¼ã‚¸ãƒ¡ãƒ³ãƒˆæ¸¬å®šã‚’è¿½åŠ 
3. é€±æ¬¡ãƒ¬ãƒãƒ¼ãƒˆè‡ªå‹•åŒ–ã‚’è¨­å®š

**ã‚¹ãƒ†ãƒƒãƒ—3: é«˜åº¦ãªæ©Ÿèƒ½ã®è¿½åŠ  (æ‰€è¦æ™‚é–“: 1é€±é–“)**
1. Claude AIçµ±åˆã§æ„Ÿæƒ…åˆ†æã‚’å®Ÿè£…
2. ã‚¹ãƒ¬ãƒƒãƒ‰åˆ†æã¨ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¨ãƒ³ã‚²ãƒ¼ã‚¸ãƒ¡ãƒ³ãƒˆè¿½åŠ 
3. ä»–MCPã‚µãƒ¼ãƒãƒ¼ã¨ã®çµ±åˆ (GitHubã€Postgres)

**ã‚¹ãƒ†ãƒƒãƒ—4: æœ¬ç•ªé‹ç”¨ã¨æœ€é©åŒ– (ç¶™ç¶šçš„)**
1. Rate Limitç®¡ç†ã¨ã‚­ãƒ£ãƒƒã‚·ãƒ³ã‚°å®Ÿè£…
2. ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã¨GDPRæº–æ‹ ã®ç¢ºä¿
3. ãƒãƒ¼ãƒ ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ã«åŸºã¥ãæ”¹å–„

<strong>æ¬¡ã®å­¦ç¿’ãƒªã‚½ãƒ¼ã‚¹:</strong>

å®Ÿè·µã‚’é€šã˜ã¦Slack MCPã®å¯èƒ½æ€§ã‚’æ¢æ±‚ã—ã€ãƒãƒ¼ãƒ ã®ã‚³ãƒŸãƒ¥ãƒ‹ã‚±ãƒ¼ã‚·ãƒ§ãƒ³æ–‡åŒ–ã‚’é€²åŒ–ã•ã›ã¾ã—ã‚‡ã†ã€‚

## å‚è€ƒè³‡æ–™

<strong>å…¬å¼ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ:</strong>
- [Model Context Protocol å…¬å¼ã‚µã‚¤ãƒˆ](https://modelcontextprotocol.io/)
- [Slack MCP Server (GitHub)](https://github.com/modelcontextprotocol/servers/tree/main/src/slack)
- [Slack API ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ](https://api.slack.com/docs)
- [Claude Code ã‚¬ã‚¤ãƒ‰](https://docs.anthropic.com/claude-code)

<strong>ã‚ªãƒ¼ãƒ—ãƒ³ã‚½ãƒ¼ã‚¹ãƒªã‚½ãƒ¼ã‚¹:</strong>
- [MCP Servers ãƒªãƒã‚¸ãƒˆãƒª](https://github.com/modelcontextprotocol/servers)
- [Community Python Slack MCP](https://github.com/slack-mcp/slack-mcp-python)
- [Slack Analytics Examples](https://github.com/topics/slack-analytics)

<strong>ã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£ã¨ã‚µãƒãƒ¼ãƒˆ:</strong>
- [MCP Discord ã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£](https://discord.gg/modelcontextprotocol)
- [Slack API Community](https://slackcommunity.com/)
- [Anthropic Developer Forum](https://community.anthropic.com/)

<strong>é–¢é€£è¨˜äº‹ã¨ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«:</strong>
- "Building AI Agents with Model Context Protocol" (Anthropic Engineering Blog)
- "Advanced Slack Analytics Techniques" (Medium)
- "GDPR-Compliant Workplace Analytics" (Privacy Engineering Blog)
