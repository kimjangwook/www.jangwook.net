---
title: OpenAI AgentKitå®Œå…¨æŒ‡å—ç¬¬2éƒ¨ï¼šå®æˆ˜åº”ç”¨ä¸é«˜çº§æ¨¡å¼
description: ä»ä¼ä¸šçº§å¤šæ™ºèƒ½ä½“ç³»ç»Ÿè®¾è®¡åˆ°ç”Ÿäº§ç¯å¢ƒéƒ¨ç½²ï¼ŒAgentKitå®æˆ˜æŒæ¡æŒ‡å—
pubDate: '2025-10-21'
heroImage: ../../../assets/blog/openai-agentkit-part2-hero.jpg
tags:
  - OpenAI
  - AgentKit
  - AI Agent
relatedPosts:
  - slug: google-analytics-mcp-automation
    score: 0.94
    reason:
      ko: 'ìë™í™”, AI/ML, DevOps, ì•„í‚¤í…ì²˜ ë¶„ì•¼ì—ì„œ ìœ ì‚¬í•œ ì£¼ì œë¥¼ ë‹¤ë£¨ë©° ë¹„ìŠ·í•œ ë‚œì´ë„ì…ë‹ˆë‹¤.'
      ja: è‡ªå‹•åŒ–ã€AI/MLã€DevOpsã€ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£åˆ†é‡ã§é¡ä¼¼ã—ãŸãƒˆãƒ”ãƒƒã‚¯ã‚’æ‰±ã„ã€åŒç¨‹åº¦ã®é›£æ˜“åº¦ã§ã™ã€‚
      en: >-
        Covers similar topics in automation, AI/ML, DevOps, architecture with
        comparable difficulty.
      zh: åœ¨è‡ªåŠ¨åŒ–ã€AI/MLã€DevOpsã€æ¶æ„é¢†åŸŸæ¶µç›–ç±»ä¼¼ä¸»é¢˜ï¼Œéš¾åº¦ç›¸å½“ã€‚
  - slug: ai-content-recommendation-system
    score: 0.94
    reason:
      ko: 'ìë™í™”, AI/ML, ì•„í‚¤í…ì²˜ ë¶„ì•¼ì—ì„œ ìœ ì‚¬í•œ ì£¼ì œë¥¼ ë‹¤ë£¨ë©° ë¹„ìŠ·í•œ ë‚œì´ë„ì…ë‹ˆë‹¤.'
      ja: è‡ªå‹•åŒ–ã€AI/MLã€ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£åˆ†é‡ã§é¡ä¼¼ã—ãŸãƒˆãƒ”ãƒƒã‚¯ã‚’æ‰±ã„ã€åŒç¨‹åº¦ã®é›£æ˜“åº¦ã§ã™ã€‚
      en: >-
        Covers similar topics in automation, AI/ML, architecture with comparable
        difficulty.
      zh: åœ¨è‡ªåŠ¨åŒ–ã€AI/MLã€æ¶æ„é¢†åŸŸæ¶µç›–ç±»ä¼¼ä¸»é¢˜ï¼Œéš¾åº¦ç›¸å½“ã€‚
  - slug: specification-driven-development
    score: 0.94
    reason:
      ko: 'ìë™í™”, AI/ML, ì•„í‚¤í…ì²˜ ë¶„ì•¼ì—ì„œ ìœ ì‚¬í•œ ì£¼ì œë¥¼ ë‹¤ë£¨ë©° ë¹„ìŠ·í•œ ë‚œì´ë„ì…ë‹ˆë‹¤.'
      ja: è‡ªå‹•åŒ–ã€AI/MLã€ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£åˆ†é‡ã§é¡ä¼¼ã—ãŸãƒˆãƒ”ãƒƒã‚¯ã‚’æ‰±ã„ã€åŒç¨‹åº¦ã®é›£æ˜“åº¦ã§ã™ã€‚
      en: >-
        Covers similar topics in automation, AI/ML, architecture with comparable
        difficulty.
      zh: åœ¨è‡ªåŠ¨åŒ–ã€AI/MLã€æ¶æ„é¢†åŸŸæ¶µç›–ç±»ä¼¼ä¸»é¢˜ï¼Œéš¾åº¦ç›¸å½“ã€‚
  - slug: metadata-based-recommendation-optimization
    score: 0.93
    reason:
      ko: 'ìë™í™”, AI/ML, DevOps, ì•„í‚¤í…ì²˜ ë¶„ì•¼ì—ì„œ ìœ ì‚¬í•œ ì£¼ì œë¥¼ ë‹¤ë£¨ë©° ë¹„ìŠ·í•œ ë‚œì´ë„ì…ë‹ˆë‹¤.'
      ja: è‡ªå‹•åŒ–ã€AI/MLã€DevOpsã€ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£åˆ†é‡ã§é¡ä¼¼ã—ãŸãƒˆãƒ”ãƒƒã‚¯ã‚’æ‰±ã„ã€åŒç¨‹åº¦ã®é›£æ˜“åº¦ã§ã™ã€‚
      en: >-
        Covers similar topics in automation, AI/ML, DevOps, architecture with
        comparable difficulty.
      zh: åœ¨è‡ªåŠ¨åŒ–ã€AI/MLã€DevOpsã€æ¶æ„é¢†åŸŸæ¶µç›–ç±»ä¼¼ä¸»é¢˜ï¼Œéš¾åº¦ç›¸å½“ã€‚
  - slug: ai-agent-collaboration-patterns
    score: 0.92
    reason:
      ko: 'ë‹¤ìŒ ë‹¨ê³„ í•™ìŠµìœ¼ë¡œ ì í•©í•˜ë©°, ìë™í™”, AI/ML, ì•„í‚¤í…ì²˜ ì£¼ì œì—ì„œ ì—°ê²°ë©ë‹ˆë‹¤.'
      ja: æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—ã®å­¦ç¿’ã«é©ã—ã¦ãŠã‚Šã€è‡ªå‹•åŒ–ã€AI/MLã€ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã®ãƒˆãƒ”ãƒƒã‚¯ã§ç¹‹ãŒã‚Šã¾ã™ã€‚
      en: >-
        Suitable as a next-step learning resource, connecting through
        automation, AI/ML, architecture topics.
      zh: é€‚åˆä½œä¸ºä¸‹ä¸€æ­¥å­¦ä¹ èµ„æºï¼Œé€šè¿‡è‡ªåŠ¨åŒ–ã€AI/MLã€æ¶æ„ä¸»é¢˜è¿›è¡Œè¿æ¥ã€‚
---

> <strong>ç³»åˆ—ï¼šæŒæ¡OpenAI AgentKit</strong> (2/2)
>
> 1. [OpenAI AgentKitå®Œå…¨æŒ‡å—ç¬¬1éƒ¨ï¼šæ ¸å¿ƒæ¦‚å¿µä¸å…¥é—¨](/zh/blog/zh/openai-agentkit-tutorial-part1)
> 2. <strong>OpenAI AgentKitå®Œå…¨æŒ‡å—ç¬¬2éƒ¨ï¼šå®æˆ˜åº”ç”¨ä¸é«˜çº§æ¨¡å¼</strong> â† å½“å‰æ–‡ç« 

# OpenAI AgentKitå®Œå…¨æŒ‡å—ç¬¬2éƒ¨ï¼šå®æˆ˜åº”ç”¨ä¸é«˜çº§æ¨¡å¼

åœ¨[ç¬¬1éƒ¨](/zh/blog/zh/openai-agentkit-tutorial-part1)ä¸­ï¼Œæˆ‘ä»¬å­¦ä¹ äº†AgentKitçš„æ ¸å¿ƒæ¦‚å¿µå’ŒåŸºæœ¬ç”¨æ³•ã€‚ç°åœ¨æˆ‘ä»¬å°†æ¢è®¨å¯åœ¨å®é™…ç”Ÿäº§ç¯å¢ƒä¸­ä½¿ç”¨çš„<strong>é«˜çº§æ¶æ„æ¨¡å¼</strong>å’Œ<strong>ä¼ä¸šçº§ç³»ç»Ÿè®¾è®¡</strong>ã€‚

æœ¬æ–‡å°†ä»‹ç»çœŸå®ä¼ä¸šå¦‚ä½•åˆ©ç”¨AgentKitè§£å†³å¤æ‚é—®é¢˜ï¼Œå¹¶æä¾›å¯ç›´æ¥å®ç°çš„<strong>å®Œæ•´ä»£ç ç¤ºä¾‹</strong>ã€‚

## æ ¸å¿ƒæ€»ç»“ (TL;DR)

- ğŸ—ï¸ <strong>3ç§ä¼ä¸šæ¶æ„æ¨¡å¼</strong>ï¼šå±‚çº§å¼ã€äº‹ä»¶é©±åŠ¨ã€åŸºäºå›¾çš„ç¼–æ’
- ğŸ”§ <strong>æ„å»ºè‡ªå®šä¹‰MCPæœåŠ¡å™¨</strong>ï¼šè‡ªè¡Œåˆ›å»ºå¹¶é›†æˆåˆ°AgentKit
- ğŸ“Š <strong>ç”Ÿäº§ç¯å¢ƒç›‘æ§</strong>ï¼šåˆ©ç”¨Evalsè¿›è¡Œæ€§èƒ½ä¼˜åŒ–å’ŒA/Bæµ‹è¯•
- ğŸ›¡ï¸ <strong>ä¼ä¸šå®‰å…¨</strong>ï¼šæ•°æ®éš”ç¦»ã€å®¡è®¡æ—¥å¿—ã€åˆè§„æ€§
- ğŸ’¼ <strong>3ä¸ªå®æˆ˜æ¡ˆä¾‹</strong>ï¼šSaaSè‡ªåŠ¨åŒ–ã€æ•°æ®ç®¡é“ã€DevOpså·¥ä½œæµ
- âš¡ <strong>æ€§èƒ½ä¼˜åŒ–</strong>ï¼šå¹¶è¡Œå¤„ç†ã€ç¼“å­˜ã€æµå¼å“åº”

## ä¼ä¸šæ¶æ„æ¨¡å¼

### æ¨¡å¼1ï¼šå±‚çº§å¼ç®¡ç†è€…-å·¥ä½œè€…ï¼ˆHierarchical Manager-Workerï¼‰

<strong>ä½¿ç”¨åœºæ™¯</strong>ï¼šå¤æ‚çš„å†³ç­–æ ‘ï¼Œéœ€è¦æ˜ç¡®çš„èŒè´£åˆ†ç¦»

```mermaid
graph TD
    Manager[ç®¡ç†è€…æ™ºèƒ½ä½“<br/>å†³ç­–ä¸è§„åˆ’] --> Worker1[å‰ç«¯ä¸“å®¶<br/>UI/UXå®ç°]
    Manager --> Worker2[åç«¯ä¸“å®¶<br/>APIä¸æ•°æ®åº“]
    Manager --> Worker3[DevOpsä¸“å®¶<br/>éƒ¨ç½²ä¸ç›‘æ§]

    Worker2 --> SubWorker1[æ•°æ®åº“ä¸“å®¶<br/>æ¨¡å¼è®¾è®¡]
    Worker2 --> SubWorker2[APIä¸“å®¶<br/>ç«¯ç‚¹è®¾è®¡]

    Worker1 -.->|æŠ¥å‘Š| Manager
    Worker2 -.->|æŠ¥å‘Š| Manager
    Worker3 -.->|æŠ¥å‘Š| Manager

    style Manager fill:#10A37F
    style Worker1 fill:#FFB800
    style Worker2 fill:#FFB800
    style Worker3 fill:#FFB800
```

#### å®ç°ç¤ºä¾‹ï¼šå…¨æ ˆåº”ç”¨ç”Ÿæˆç³»ç»Ÿ

```python
from agents import Agent, Runner

# 1. ç®¡ç†è€…æ™ºèƒ½ä½“ï¼ˆæœ€é«˜å±‚ï¼‰
manager = Agent(
    name="Project Manager",
    instructions="""
    You are a technical project manager for building web applications.

    Your responsibilities:
    1. Analyze user requirements
    2. Break down into tasks
    3. Delegate to specialist agents
    4. Coordinate between teams
    5. Ensure quality standards
    6. Report progress

    Decision framework:
    - Frontend tasks â†’ Frontend Specialist
    - Backend/API tasks â†’ Backend Specialist
    - Database tasks â†’ Backend Specialist (who delegates to Database Expert)
    - Deployment tasks â†’ DevOps Specialist

    Always verify feasibility before delegation.
    """,
    handoffs=[
        "Frontend Specialist",
        "Backend Specialist",
        "DevOps Specialist"
    ]
)

# 2. å‰ç«¯ä¸“å®¶
frontend_specialist = Agent(
    name="Frontend Specialist",
    instructions="""
    You specialize in frontend development.

    Skills:
    - React/Next.js component design
    - Tailwind CSS styling
    - Responsive layouts
    - Form validation
    - State management

    When you receive a task:
    1. Design component structure
    2. Implement with best practices
    3. Ensure accessibility (WCAG)
    4. Test on multiple screen sizes
    5. Report completion to Project Manager
    """,
    tools=[create_component, add_styling, validate_accessibility],
    handoffs=["Project Manager"]
)

# 3. åç«¯ä¸“å®¶
backend_specialist = Agent(
    name="Backend Specialist",
    instructions="""
    You specialize in backend development.

    Skills:
    - RESTful API design
    - Database schema design
    - Authentication/authorization
    - Error handling
    - Performance optimization

    For complex database tasks, delegate to Database Expert.
    For API design, handle directly.
    """,
    tools=[create_api_endpoint, design_schema],
    handoffs=["Database Expert", "Project Manager"]
)

# 4. æ•°æ®åº“ä¸“å®¶ï¼ˆå­ä¸“å®¶ï¼‰
database_expert = Agent(
    name="Database Expert",
    instructions="""
    You are a database specialist.

    Expertise:
    - PostgreSQL, MongoDB, Redis
    - Index optimization
    - Query performance tuning
    - Migration strategies
    - Backup/recovery

    Always consider:
    - Data integrity constraints
    - Scalability
    - Query performance
    - Migration path
    """,
    tools=[create_migration, optimize_query, add_index],
    handoffs=["Backend Specialist"]
)

# 5. DevOpsä¸“å®¶
devops_specialist = Agent(
    name="DevOps Specialist",
    instructions="""
    You handle deployment and infrastructure.

    Responsibilities:
    - CI/CD pipeline setup
    - Docker containerization
    - Kubernetes deployment
    - Monitoring setup
    - Security hardening

    Follow the 12-factor app principles.
    """,
    tools=[create_dockerfile, setup_ci_cd, deploy_to_k8s],
    handoffs=["Project Manager"]
)
```

#### æ‰§è¡Œç¤ºä¾‹

```python
# ç”¨æˆ·è¯·æ±‚
user_request = """
Create a task management SaaS application with:
- User authentication
- Task CRUD operations
- Real-time updates
- Dashboard with analytics
- Mobile responsive
- Deploy to production
"""

# ç®¡ç†è€…åè°ƒæ•´ä¸ªé¡¹ç›®
result = Runner.run_sync(
    manager,
    user_request
)

# æ‰§è¡Œæµç¨‹ï¼š
# 1. Manager: éœ€æ±‚åˆ†æä¸ä»»åŠ¡åˆ†è§£
# 2. Manager â†’ Frontend Specialist: åˆ›å»ºUIç»„ä»¶
# 3. Manager â†’ Backend Specialist: APIè®¾è®¡
# 4. Backend Specialist â†’ Database Expert: æ¨¡å¼è®¾è®¡
# 5. Database Expert â†’ Backend Specialist: å®ŒæˆæŠ¥å‘Š
# 6. Backend Specialist â†’ Manager: å®ŒæˆæŠ¥å‘Š
# 7. Manager â†’ DevOps Specialist: éƒ¨ç½²
# 8. DevOps Specialist â†’ Manager: éƒ¨ç½²å®Œæˆ
# 9. Manager â†’ User: é¡¹ç›®å®ŒæˆæŠ¥å‘Š
```

<strong>ä¼˜ç‚¹</strong>ï¼š
- æ˜ç¡®çš„èŒè´£åˆ†ç¦»
- å¯æ‰©å±•ï¼ˆæ˜“äºæ·»åŠ æ–°ä¸“å®¶ï¼‰
- æ˜“äºè°ƒè¯•ï¼ˆåˆ†å±‚è¿½è¸ªï¼‰
- èµ„æºé«˜æ•ˆï¼ˆä»…è°ƒç”¨æ‰€éœ€ä¸“å®¶ï¼‰

<strong>ç¼ºç‚¹</strong>ï¼š
- ç®¡ç†è€…å¯èƒ½æˆä¸ºç“¶é¢ˆ
- å±‚çº§è¿‡æ·±æ—¶å»¶è¿Ÿå¢åŠ 
- ä¾èµ–ç®¡ç†è€…çš„å†³ç­–è´¨é‡

---

### æ¨¡å¼2ï¼šäº‹ä»¶é©±åŠ¨ç¼–æ’ï¼ˆEvent-Driven Orchestrationï¼‰

<strong>ä½¿ç”¨åœºæ™¯</strong>ï¼šå¼‚æ­¥ä»»åŠ¡ã€æ¾è€¦åˆã€åŠ¨æ€å·¥ä½œæµ

```mermaid
graph LR
    Event[äº‹ä»¶æ€»çº¿<br/>æ¶ˆæ¯é˜Ÿåˆ—]

    A1[æ™ºèƒ½ä½“A<br/>å‘å¸ƒäº‹ä»¶] -->|event_type: user_created| Event
    Event -->|è®¢é˜…| A2[æ™ºèƒ½ä½“B<br/>å‘é€é‚®ä»¶]
    Event -->|è®¢é˜…| A3[æ™ºèƒ½ä½“C<br/>åˆ›å»ºé…ç½®æ–‡ä»¶]
    Event -->|è®¢é˜…| A4[æ™ºèƒ½ä½“D<br/>åˆ†ææ—¥å¿—]

    A2 -->|event: email_sent| Event
    A3 -->|event: profile_created| Event

    Event -->|è®¢é˜…| A5[æ™ºèƒ½ä½“E<br/>å¼€å§‹å…¥é—¨æµç¨‹]

    style Event fill:#10A37F
    style A1 fill:#FFB800
    style A2 fill:#6C63FF
    style A3 fill:#6C63FF
    style A4 fill:#6C63FF
    style A5 fill:#FF6584
```

#### å®ç°ç¤ºä¾‹ï¼šç”¨æˆ·å…¥é—¨è‡ªåŠ¨åŒ–

```python
from agents import Agent
import asyncio
from typing import Dict, List

class EventBus:
    def __init__(self):
        self.subscribers: Dict[str, List[Agent]] = {}

    def subscribe(self, event_type: str, agent: Agent):
        """å°†æ™ºèƒ½ä½“è®¢é˜…åˆ°ç‰¹å®šäº‹ä»¶"""
        if event_type not in self.subscribers:
            self.subscribers[event_type] = []
        self.subscribers[event_type].append(agent)

    async def publish(self, event_type: str, data: dict):
        """å‘å¸ƒäº‹ä»¶å¹¶ä¼ é€’ç»™æ‰€æœ‰è®¢é˜…è€…"""
        if event_type in self.subscribers:
            tasks = []
            for agent in self.subscribers[event_type]:
                task = Runner.run(agent, f"Handle event: {event_type}\nData: {data}")
                tasks.append(task)

            # å¹¶è¡Œæ‰§è¡Œ
            results = await asyncio.gather(*tasks, return_exceptions=True)
            return results
        return []

# åˆå§‹åŒ–äº‹ä»¶æ€»çº¿
event_bus = EventBus()

# 1. ç”¨æˆ·åˆ›å»ºæ™ºèƒ½ä½“
user_creator = Agent(
    name="User Creator",
    instructions="""
    Create new user accounts.
    After creating a user, publish a 'user_created' event.
    """,
    tools=[create_user_in_db]
)

# 2. é‚®ä»¶å‘é€æ™ºèƒ½ä½“
email_agent = Agent(
    name="Email Sender",
    instructions="""
    Send welcome emails to new users.
    Listen for 'user_created' events.
    After sending, publish 'email_sent' event.
    """,
    tools=[send_welcome_email]
)

# 3. é…ç½®æ–‡ä»¶åˆ›å»ºæ™ºèƒ½ä½“
profile_agent = Agent(
    name="Profile Creator",
    instructions="""
    Create user profiles with default settings.
    Listen for 'user_created' events.
    After creation, publish 'profile_created' event.
    """,
    tools=[create_default_profile]
)

# 4. åˆ†ææ—¥å¿—æ™ºèƒ½ä½“
analytics_agent = Agent(
    name="Analytics Logger",
    instructions="""
    Log user creation events for analytics.
    Listen for 'user_created' events.
    No event publication needed.
    """,
    tools=[log_to_analytics]
)

# 5. å…¥é—¨æ™ºèƒ½ä½“
onboarding_agent = Agent(
    name="Onboarding Coordinator",
    instructions="""
    Start user onboarding flow.
    Wait for both 'email_sent' AND 'profile_created' events.
    Then initiate the onboarding tutorial.
    """,
    tools=[start_onboarding_tutorial]
)

# è®¾ç½®äº‹ä»¶è®¢é˜…
event_bus.subscribe("user_created", email_agent)
event_bus.subscribe("user_created", profile_agent)
event_bus.subscribe("user_created", analytics_agent)
event_bus.subscribe("email_sent", onboarding_agent)
event_bus.subscribe("profile_created", onboarding_agent)

# ä½¿ç”¨ç¤ºä¾‹
async def create_new_user(user_data: dict):
    # 1. åˆ›å»ºç”¨æˆ·
    result = await Runner.run(user_creator, f"Create user: {user_data}")

    # 2. å‘å¸ƒuser_createdäº‹ä»¶ï¼ˆå¹¶è¡Œæ‰§è¡Œï¼‰
    await event_bus.publish("user_created", {"user_id": result.user_id, **user_data})

    # é‚®ä»¶ã€é…ç½®æ–‡ä»¶ã€åˆ†ææ—¥å¿—åŒæ—¶å¤„ç†
```

<strong>ä¼˜ç‚¹</strong>ï¼š
- æ™ºèƒ½ä½“é—´æ¾è€¦åˆ
- å¹¶è¡Œå¤„ç†æå‡æ€§èƒ½
- æ˜“äºæ·»åŠ æ–°åŠŸèƒ½ï¼ˆä»…æ·»åŠ æ–°è®¢é˜…è€…ï¼‰
- æ•…éšœéš”ç¦»ï¼ˆä¸€ä¸ªå¤±è´¥ä¸å½±å“å…¶ä»–ï¼‰

<strong>ç¼ºç‚¹</strong>ï¼š
- è°ƒè¯•å›°éš¾ï¼ˆå¼‚æ­¥æµç¨‹ï¼‰
- éš¾ä»¥ä¿è¯äº‹ä»¶é¡ºåº
- å¤æ‚åº¦å¢åŠ 

---

### æ¨¡å¼3ï¼šåŸºäºå›¾çš„å·¥ä½œæµï¼ˆGraph-Based Workflowï¼‰

<strong>ä½¿ç”¨åœºæ™¯</strong>ï¼šå¤æ‚çš„æ¡ä»¶æµç¨‹ã€å¾ªç¯ã€åŠ¨æ€å†³ç­–

```mermaid
graph TD
    Start[å¼€å§‹] --> Analyze[éœ€æ±‚åˆ†æ]
    Analyze --> Design{è®¾è®¡å¤æ‚åº¦ï¼Ÿ}

    Design -->|ç®€å•| SimpleImpl[ç›´æ¥å®ç°]
    Design -->|å¤æ‚| Research[é¢å¤–ç ”ç©¶]

    Research --> ArchDesign[æ¶æ„è®¾è®¡]
    ArchDesign --> Review{å®¡æŸ¥é€šè¿‡ï¼Ÿ}

    Review -->|å¦| ArchDesign
    Review -->|æ˜¯| Implement[å®ç°]

    SimpleImpl --> Test[æµ‹è¯•]
    Implement --> Test

    Test --> QA{QAé€šè¿‡ï¼Ÿ}
    QA -->|å¦| Debug[è°ƒè¯•]
    Debug --> Test
    QA -->|æ˜¯| Deploy[éƒ¨ç½²]

    Deploy --> Monitor[ç›‘æ§]
    Monitor --> Issue{å‘ç°é—®é¢˜ï¼Ÿ}
    Issue -->|æ˜¯| Debug
    Issue -->|å¦| End[å®Œæˆ]

    style Start fill:#10A37F
    style End fill:#10A37F
    style Design fill:#FFB800
    style Review fill:#FFB800
    style QA fill:#FFB800
    style Issue fill:#FFB800
```

#### å®ç°ç¤ºä¾‹ï¼šåˆ©ç”¨LangGraph

```python
from langgraph.graph import StateGraph, END
from agents import Agent
from typing import TypedDict, Annotated

# 1. çŠ¶æ€å®šä¹‰
class ProjectState(TypedDict):
    requirements: str
    design: dict
    code: str
    test_results: dict
    deployment_status: str
    issues: list
    iteration_count: int

# 2. æ™ºèƒ½ä½“å®šä¹‰
analyzer = Agent(
    name="Requirement Analyzer",
    instructions="Analyze requirements and determine complexity",
    tools=[analyze_complexity]
)

designer = Agent(
    name="System Designer",
    instructions="Design system architecture",
    tools=[create_architecture_diagram]
)

implementer = Agent(
    name="Code Implementer",
    instructions="Implement the design in code",
    tools=[write_code, run_linter]
)

tester = Agent(
    name="QA Tester",
    instructions="Test the implementation",
    tools=[run_tests, check_coverage]
)

deployer = Agent(
    name="Deployment Engineer",
    instructions="Deploy to production",
    tools=[deploy_to_prod, setup_monitoring]
)

# 3. èŠ‚ç‚¹å‡½æ•°å®šä¹‰
async def analyze_node(state: ProjectState) -> ProjectState:
    result = await Runner.run(analyzer, state["requirements"])
    state["design"] = {"complexity": result.complexity, "approach": result.approach}
    return state

async def design_node(state: ProjectState) -> ProjectState:
    result = await Runner.run(designer, f"Design for: {state['design']}")
    state["design"]["architecture"] = result.architecture
    return state

async def implement_node(state: ProjectState) -> ProjectState:
    result = await Runner.run(implementer, f"Implement: {state['design']}")
    state["code"] = result.code
    return state

async def test_node(state: ProjectState) -> ProjectState:
    result = await Runner.run(tester, f"Test: {state['code']}")
    state["test_results"] = result.test_results
    state["issues"] = result.issues
    return state

async def deploy_node(state: ProjectState) -> ProjectState:
    result = await Runner.run(deployer, f"Deploy: {state['code']}")
    state["deployment_status"] = result.status
    return state

# 4. æ¡ä»¶è·¯ç”±å‡½æ•°
def should_research(state: ProjectState) -> str:
    if state["design"]["complexity"] == "high":
        return "design"
    return "implement"

def test_passed(state: ProjectState) -> str:
    if state["issues"]:
        if state["iteration_count"] < 3:
            state["iteration_count"] += 1
            return "implement"  # é‡æ–°å®ç°
        return "escalate"  # äººå·¥ä»‹å…¥
    return "deploy"

# 5. å›¾æ„å»º
workflow = StateGraph(ProjectState)

# æ·»åŠ èŠ‚ç‚¹
workflow.add_node("analyze", analyze_node)
workflow.add_node("design", design_node)
workflow.add_node("implement", implement_node)
workflow.add_node("test", test_node)
workflow.add_node("deploy", deploy_node)

# æ·»åŠ è¾¹
workflow.set_entry_point("analyze")
workflow.add_conditional_edges(
    "analyze",
    should_research,
    {"design": "design", "implement": "implement"}
)
workflow.add_edge("design", "implement")
workflow.add_edge("implement", "test")
workflow.add_conditional_edges(
    "test",
    test_passed,
    {"deploy": "deploy", "implement": "implement", "escalate": END}
)
workflow.add_edge("deploy", END)

# 6. ç¼–è¯‘å¹¶æ‰§è¡Œ
app = workflow.compile()

# ä½¿ç”¨
initial_state = {
    "requirements": "Build a real-time chat application with video calls",
    "design": {},
    "code": "",
    "test_results": {},
    "deployment_status": "",
    "issues": [],
    "iteration_count": 0
}

final_state = await app.ainvoke(initial_state)
```

<strong>ä¼˜ç‚¹</strong>ï¼š
- è¡¨è¾¾å¤æ‚çš„æ¡ä»¶é€»è¾‘
- æ”¯æŒå¾ªç¯å’Œé‡è¯•
- å¯è§†åŒ–ï¼ˆå›¾è¡¨ç¤ºï¼‰
- åŠ¨æ€å·¥ä½œæµå˜æ›´

<strong>ç¼ºç‚¹</strong>ï¼š
- åˆå§‹è®¾ç½®å¤æ‚
- éœ€è¦çŠ¶æ€ç®¡ç†
- ä¾èµ–LangGraph

---

## æ„å»ºè‡ªå®šä¹‰MCPæœåŠ¡å™¨

ä½¿ç”¨MCPï¼ˆModel Context Protocolï¼‰å¯ä»¥ä»¥æ ‡å‡†åŒ–æ–¹å¼å°†AgentKitè¿æ¥åˆ°å¤–éƒ¨ç³»ç»Ÿã€‚

### å®æˆ˜ç¤ºä¾‹ï¼šæ„å»ºSlack MCPæœåŠ¡å™¨

<strong>ç›®æ ‡</strong>ï¼šä½¿AgentKitæ™ºèƒ½ä½“èƒ½å¤Ÿå‘é€Slackæ¶ˆæ¯ã€ç®¡ç†é¢‘é“å’Œæ·»åŠ ååº”

#### 1. MCPæœåŠ¡å™¨ç»“æ„

```python
# slack_mcp_server.py
from mcp.server import Server, Tool
from slack_sdk import WebClient
from slack_sdk.errors import SlackApiError
import os

class SlackMCPServer(Server):
    def __init__(self):
        super().__init__(name="slack", version="1.0.0")
        self.client = WebClient(token=os.environ["SLACK_BOT_TOKEN"])

        # æ³¨å†Œå·¥å…·
        self.register_tool(self.send_message)
        self.register_tool(self.create_channel)
        self.register_tool(self.add_reaction)
        self.register_tool(self.get_channel_history)

    @Tool(
        name="send_message",
        description="Send a message to a Slack channel",
        parameters={
            "channel": {
                "type": "string",
                "description": "Channel ID or name (e.g., '#general')"
            },
            "text": {
                "type": "string",
                "description": "Message text"
            },
            "thread_ts": {
                "type": "string",
                "description": "Thread timestamp (optional, for replies)",
                "optional": True
            }
        }
    )
    async def send_message(self, channel: str, text: str, thread_ts: str = None):
        """å‘é€Slackæ¶ˆæ¯"""
        try:
            response = self.client.chat_postMessage(
                channel=channel,
                text=text,
                thread_ts=thread_ts
            )
            return {
                "success": True,
                "ts": response["ts"],
                "channel": response["channel"]
            }
        except SlackApiError as e:
            return {
                "success": False,
                "error": str(e)
            }

    @Tool(
        name="create_channel",
        description="Create a new Slack channel",
        parameters={
            "name": {
                "type": "string",
                "description": "Channel name (lowercase, no spaces)"
            },
            "is_private": {
                "type": "boolean",
                "description": "Whether the channel is private",
                "default": False
            }
        }
    )
    async def create_channel(self, name: str, is_private: bool = False):
        """åˆ›å»ºæ–°çš„Slacké¢‘é“"""
        try:
            response = self.client.conversations_create(
                name=name,
                is_private=is_private
            )
            return {
                "success": True,
                "channel_id": response["channel"]["id"],
                "channel_name": response["channel"]["name"]
            }
        except SlackApiError as e:
            return {
                "success": False,
                "error": str(e)
            }

    @Tool(
        name="add_reaction",
        description="Add an emoji reaction to a message",
        parameters={
            "channel": {"type": "string", "description": "Channel ID"},
            "timestamp": {"type": "string", "description": "Message timestamp"},
            "name": {"type": "string", "description": "Emoji name (without colons)"}
        }
    )
    async def add_reaction(self, channel: str, timestamp: str, name: str):
        """åœ¨æ¶ˆæ¯ä¸Šæ·»åŠ è¡¨æƒ…ååº”"""
        try:
            self.client.reactions_add(
                channel=channel,
                timestamp=timestamp,
                name=name
            )
            return {"success": True}
        except SlackApiError as e:
            return {"success": False, "error": str(e)}

    @Tool(
        name="get_channel_history",
        description="Get recent messages from a channel",
        parameters={
            "channel": {"type": "string", "description": "Channel ID"},
            "limit": {"type": "integer", "description": "Number of messages", "default": 10}
        }
    )
    async def get_channel_history(self, channel: str, limit: int = 10):
        """è·å–é¢‘é“çš„æœ€è¿‘æ¶ˆæ¯"""
        try:
            response = self.client.conversations_history(
                channel=channel,
                limit=limit
            )
            messages = []
            for msg in response["messages"]:
                messages.append({
                    "text": msg.get("text", ""),
                    "user": msg.get("user", ""),
                    "timestamp": msg["ts"]
                })
            return {"success": True, "messages": messages}
        except SlackApiError as e:
            return {"success": False, "error": str(e)}

# è¿è¡ŒæœåŠ¡å™¨
if __name__ == "__main__":
    server = SlackMCPServer()
    server.run(host="localhost", port=3000)
```

#### 2. åœ¨AgentKitä¸­ä½¿ç”¨MCPæœåŠ¡å™¨

```python
from agents import Agent
from agents.mcp import MCPServer

# è¿æ¥MCPæœåŠ¡å™¨
slack_server = MCPServer(
    url="http://localhost:3000",
    name="slack"
)

# Slackç®¡ç†æ™ºèƒ½ä½“
slack_agent = Agent(
    name="Slack Manager",
    instructions="""
    You manage Slack communications.

    Capabilities:
    - Send messages to channels
    - Create new channels
    - Add reactions
    - Read channel history

    Best practices:
    - Use threads for related conversations
    - Add emoji reactions to acknowledge messages
    - Create channels with clear, descriptive names
    - Check channel history before sending duplicates
    """,
    mcp_servers=[slack_server]
)

# ä½¿ç”¨ç¤ºä¾‹
result = Runner.run_sync(
    slack_agent,
    """
    Create a new channel called 'project-agentkit-updates'.
    Then send a message: "AgentKit integration is now live!ğŸš€"
    Add a thumbs up reaction to confirm.
    """
)
```

#### 3. ä½¿ç”¨Connector Registryè¿›è¡Œä¼ä¸šç®¡ç†

```python
from agents import ConnectorRegistry

# ç»„ç»‡çš„MCPæœåŠ¡å™¨é›†ä¸­ç®¡ç†
registry = ConnectorRegistry()

# æ³¨å†ŒSlack MCP
registry.add_server(
    name="Company Slack",
    mcp_url="http://internal-mcp.company.com/slack",
    permissions=["read", "write"],
    allowed_teams=["engineering", "product", "marketing"],
    rate_limits={"requests_per_minute": 60},
    audit_logging=True
)

# æ³¨å†ŒGitHub MCP
registry.add_server(
    name="Company GitHub",
    mcp_url="http://internal-mcp.company.com/github",
    permissions=["read", "write"],
    allowed_teams=["engineering"],
    rate_limits={"requests_per_minute": 30},
    require_approval=True  # PRåˆ›å»º/åˆå¹¶éœ€è¦æ‰¹å‡†
)

# åœ¨æ™ºèƒ½ä½“ä¸­ä½¿ç”¨æ³¨å†Œè¡¨
devops_agent = Agent(
    name="DevOps Automator",
    instructions="Automate DevOps workflows",
    connector_registry=registry
)

# ç¡®è®¤æƒé™åæ‰§è¡Œæ“ä½œ
result = Runner.run_sync(
    devops_agent,
    """
    When the build succeeds:
    1. Send a message to #deployments Slack channel
    2. Create a GitHub release
    3. Update the status page
    """
)
```

---

## ç”Ÿäº§ç¯å¢ƒç›‘æ§ä¸ä¼˜åŒ–

### åˆ©ç”¨Evalsè¿›è¡Œæ€§èƒ½æµ‹é‡

#### 1. åŸºæœ¬æŒ‡æ ‡è¿½è¸ª

```python
from agents import Evals, Runner

evals = Evals()

# æ™ºèƒ½ä½“æ‰§è¡Œä¸è‡ªåŠ¨è¿½è¸ª
@evals.track(
    agent_name="Customer Support",
    metrics=["latency", "cost", "success_rate", "user_satisfaction"]
)
async def handle_support_ticket(ticket):
    result = await Runner.run(support_agent, ticket)
    return result

# æŸ¥è¯¢æŒ‡æ ‡
metrics = evals.get_metrics(
    agent_name="Customer Support",
    time_range="last_7_days"
)

print(f"å¹³å‡å“åº”æ—¶é—´: {metrics['avg_latency']}ms")
print(f"æ€»æˆæœ¬: ${metrics['total_cost']}")
print(f"æˆåŠŸç‡: {metrics['success_rate']}%")
```

#### 2. A/Bæµ‹è¯•æ¡†æ¶

```python
from agents import Evals, Agent, Runner
import random

evals = Evals()

# ä¸¤ä¸ªæç¤ºè¯ç‰ˆæœ¬
prompt_a = """
You are a concise customer support agent.
Answer questions directly and briefly.
"""

prompt_b = """
You are a friendly customer support agent.
Answer questions warmly with examples and explanations.
Use emoji to make responses engaging.
"""

agent_a = Agent(name="Support A", instructions=prompt_a)
agent_b = Agent(name="Support B", instructions=prompt_b)

# è¿è¡ŒA/Bæµ‹è¯•
@evals.ab_test(
    variant_a=agent_a,
    variant_b=agent_b,
    split_ratio=0.5,  # 50/50åˆ†é…
    success_metric="user_satisfaction"
)
async def handle_ticket(ticket, user_id):
    # Evalsè‡ªåŠ¨è·¯ç”±åˆ°Aæˆ–B
    result = await Runner.run(ticket)

    # æ”¶é›†ç”¨æˆ·æ»¡æ„åº¦
    satisfaction = await get_user_feedback(user_id)
    evals.log_metric("user_satisfaction", satisfaction)

    return result

# 1000æ¬¡æ‰§è¡Œååˆ†æç»“æœ
results = evals.get_ab_test_results(
    test_name="support_prompt_test",
    min_sample_size=500
)

print(f"""
A/Bæµ‹è¯•ç»“æœï¼š
å˜ä½“Aï¼ˆç®€æ´é£æ ¼ï¼‰ï¼š
  - ç”¨æˆ·æ»¡æ„åº¦: {results['a']['user_satisfaction']:.2f}/5
  - å¹³å‡å“åº”æ—¶é—´: {results['a']['avg_latency']}ms
  - æˆæœ¬: ${results['a']['avg_cost']}

å˜ä½“Bï¼ˆå‹å¥½é£æ ¼ï¼‰ï¼š
  - ç”¨æˆ·æ»¡æ„åº¦: {results['b']['user_satisfaction']:.2f}/5
  - å¹³å‡å“åº”æ—¶é—´: {results['b']['avg_latency']}ms
  - æˆæœ¬: ${results['b']['avg_cost']}

ç»Ÿè®¡æ˜¾è‘—æ€§: p-value = {results['p_value']}
æ¨è: å˜ä½“{"B" if results['recommendation'] == 'b' else "A"}
""")
```

#### 3. è‡ªåŠ¨æç¤ºè¯ä¼˜åŒ–

```python
from agents import Evals

evals = Evals()

# ä¼˜åŒ–ç›®æ ‡æ™ºèƒ½ä½“
base_agent = Agent(
    name="Code Reviewer",
    instructions="Review code for bugs and suggest improvements"
)

# è¿è¡Œè‡ªåŠ¨ä¼˜åŒ–
optimized_agent = evals.optimize_prompt(
    agent=base_agent,
    optimization_goal="success_rate",  # æˆ–"latency", "cost", "user_satisfaction"
    training_data=[
        {"input": "Review this code: ...", "expected_output": "..."},
        # 100ä¸ªä»¥ä¸Šçš„ç¤ºä¾‹
    ],
    iterations=50,  # 50æ¬¡è¿­ä»£å®éªŒ
    search_strategy="evolutionary"  # æˆ–"grid_search", "bayesian"
)

# ç»“æœæ¯”è¾ƒ
comparison = evals.compare_agents(
    agents=[base_agent, optimized_agent],
    test_data=test_dataset
)

print(f"""
åŸºçº¿ vs ä¼˜åŒ–ï¼š
æˆåŠŸç‡: {comparison['base']['success_rate']}% â†’ {comparison['optimized']['success_rate']}%
æ”¹è¿›: +{comparison['improvement']['success_rate']}%
""")
```

---

## ä¼ä¸šå®‰å…¨ä¸åˆè§„æ€§

### 1. æ•°æ®éš”ç¦»ï¼ˆå¤šç§Ÿæˆ·ï¼‰

```python
from agents import Agent, Session
import hashlib

class TenantIsolatedAgent:
    def __init__(self, base_agent: Agent):
        self.base_agent = base_agent
        self.tenant_sessions = {}

    def get_session(self, tenant_id: str) -> Session:
        """ç§Ÿæˆ·éš”ç¦»ä¼šè¯"""
        if tenant_id not in self.tenant_sessions:
            # ä¸ºæ¯ä¸ªç§Ÿæˆ·åˆ›å»ºç‹¬ç«‹ä¼šè¯
            session = Session(
                session_id=self._generate_session_id(tenant_id),
                metadata={"tenant_id": tenant_id},
                isolation_level="tenant"  # æ•°æ®éš”ç¦»
            )
            self.tenant_sessions[tenant_id] = session
        return self.tenant_sessions[tenant_id]

    async def run(self, tenant_id: str, prompt: str):
        """ç§Ÿæˆ·éš”ç¦»æ‰§è¡Œ"""
        session = self.get_session(tenant_id)

        # åº”ç”¨ç§Ÿæˆ·ä¸“å±é˜²æŠ¤æ 
        guardrails = self._get_tenant_guardrails(tenant_id)

        # æ‰§è¡Œ
        result = await Runner.run(
            self.base_agent,
            prompt,
            session=session,
            guardrails=guardrails
        )

        # å®¡è®¡æ—¥å¿—
        await self._audit_log(tenant_id, prompt, result)

        return result

    def _generate_session_id(self, tenant_id: str) -> str:
        return hashlib.sha256(tenant_id.encode()).hexdigest()

    def _get_tenant_guardrails(self, tenant_id: str):
        # ç§Ÿæˆ·å®šåˆ¶é˜²æŠ¤æ 
        return [
            guardrails.no_pii,
            guardrails.tenant_data_access(allowed_tenant=tenant_id),
            guardrails.rate_limit(tenant_id=tenant_id)
        ]

    async def _audit_log(self, tenant_id, prompt, result):
        # è®°å½•å®¡è®¡æ—¥å¿—
        log_entry = {
            "timestamp": datetime.utcnow(),
            "tenant_id": tenant_id,
            "prompt_hash": hashlib.sha256(prompt.encode()).hexdigest(),
            "result_status": result.status,
            "cost": result.cost,
            "latency": result.latency
        }
        await save_audit_log(log_entry)
```

### 2. GDPR/CCPAåˆè§„æ€§

```python
from agents import guardrails

# PIIæ£€æµ‹ä¸å¤„ç†é˜²æŠ¤æ 
class PIIComplianceGuardrail(guardrails.Guardrail):
    def __init__(self, region: str = "EU"):
        self.region = region
        self.pii_patterns = {
            "email": r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b',
            "phone": r'\b\d{3}[-.]?\d{3}[-.]?\d{4}\b',
            "ssn": r'\b\d{3}-\d{2}-\d{4}\b',
            "credit_card": r'\b\d{4}[-\s]?\d{4}[-\s]?\d{4}[-\s]?\d{4}\b'
        }

    def validate_input(self, text: str) -> tuple[bool, str]:
        """æ£€æµ‹è¾“å…¥ä¸­çš„PII"""
        detected_pii = []
        for pii_type, pattern in self.pii_patterns.items():
            if re.search(pattern, text):
                detected_pii.append(pii_type)

        if detected_pii:
            return False, f"PII detected: {', '.join(detected_pii)}. Cannot process."
        return True, ""

    def anonymize_output(self, text: str) -> str:
        """åŒ¿ååŒ–è¾“å‡ºä¸­çš„PII"""
        for pii_type, pattern in self.pii_patterns.items():
            text = re.sub(pattern, f"[{pii_type.upper()}_REDACTED]", text)
        return text

# ä½¿ç”¨
compliant_agent = Agent(
    name="GDPR Compliant Agent",
    instructions="...",
    input_guardrails=[PIIComplianceGuardrail(region="EU")],
    output_guardrails=[PIIComplianceGuardrail(region="EU")],
    data_retention_days=30,  # GDPR: æ•°æ®ä¿ç•™æœŸé™
    user_consent_required=True
)
```

### 3. å®¡è®¡æ—¥å¿—ä¸è¿½è¸ª

```python
from agents import Agent, AuditLogger

# è®¾ç½®å®¡è®¡æ—¥å¿—è®°å½•å™¨
audit_logger = AuditLogger(
    storage="postgresql://audit_db",
    retention_period_days=365,  # ä¿ç•™1å¹´
    fields=[
        "timestamp",
        "user_id",
        "agent_name",
        "input_hash",  # ä¸å­˜å‚¨å®é™…è¾“å…¥ï¼ˆéšç§ï¼‰
        "output_hash",
        "tools_used",
        "cost",
        "latency",
        "guardrail_triggers",
        "handoffs"
    ]
)

# å°†å®¡è®¡æ—¥å¿—è®°å½•å™¨è¿æ¥åˆ°æ™ºèƒ½ä½“
audited_agent = Agent(
    name="Financial Advisor",
    instructions="...",
    audit_logger=audit_logger,
    compliance_mode=True  # è®°å½•æ‰€æœ‰æ´»åŠ¨
)

# æŸ¥è¯¢å®¡è®¡æ—¥å¿—
logs = audit_logger.query(
    user_id="user_12345",
    date_range=("2025-01-01", "2025-01-31"),
    agent_name="Financial Advisor"
)

# å¼‚å¸¸æ£€æµ‹
anomalies = audit_logger.detect_anomalies(
    metrics=["cost", "latency", "guardrail_triggers"],
    threshold=2.5  # å¹³å‡å€¼çš„2.5ä¸ªæ ‡å‡†å·®ä»¥ä¸Š
)
```

---

## å®æˆ˜æ¡ˆä¾‹ç ”ç©¶

### æ¡ˆä¾‹1ï¼šSaaSå®¢æˆ·å…¥é—¨è‡ªåŠ¨åŒ–

<strong>ä¼ä¸š</strong>ï¼šB2B SaaSï¼ˆé¡¹ç›®ç®¡ç†å·¥å…·ï¼‰
<strong>ç›®æ ‡</strong>ï¼šå°†æ–°å®¢æˆ·å…¥é—¨æ—¶é—´ç¼©çŸ­70%

#### ç³»ç»Ÿæ¶æ„

```mermaid
sequenceDiagram
    participant User as æ–°å®¢æˆ·
    participant Onboarding as å…¥é—¨æ™ºèƒ½ä½“
    participant Setup as è®¾ç½®æ™ºèƒ½ä½“
    participant Training as åŸ¹è®­æ™ºèƒ½ä½“
    participant Support as æ”¯æŒæ™ºèƒ½ä½“

    User->>Onboarding: æ³¨å†Œå®Œæˆ
    Onboarding->>Setup: è´¦æˆ·åˆå§‹åŒ–
    Setup->>Setup: åˆ›å»ºé»˜è®¤é¡¹ç›®
    Setup->>Setup: é‚€è¯·å›¢é˜Ÿæˆå‘˜
    Setup-->>Onboarding: è®¾ç½®å®Œæˆ

    Onboarding->>Training: å¼€å§‹å®šåˆ¶æ•™ç¨‹
    Training->>User: æä¾›åˆ†æ­¥æŒ‡å—
    User->>Training: å®Œæˆæ•™ç¨‹
    Training-->>Onboarding: åŸ¹è®­å®Œæˆ

    Onboarding->>Support: æ¿€æ´»ç¬¬ä¸€å‘¨é›†ä¸­æ”¯æŒ
    Support->>User: ä¸»åŠ¨æä¾›å¸®åŠ©

    Onboarding->>User: å…¥é—¨å®Œæˆ ğŸ‰
```

#### å®ç°ä»£ç 

```python
from agents import Agent, Runner

# 1. å…¥é—¨åè°ƒå™¨
onboarding_orchestrator = Agent(
    name="Onboarding Orchestrator",
    instructions="""
    You coordinate the entire customer onboarding process.

    Steps:
    1. Welcome the customer
    2. Delegate account setup to Setup Agent
    3. Delegate training to Training Agent
    4. Activate proactive support
    5. Schedule follow-ups

    Success criteria:
    - Customer completes 3+ tasks
    - Team invited
    - First project created
    """,
    handoffs=["Setup Agent", "Training Agent", "Support Agent"]
)

# 2. è®¾ç½®æ™ºèƒ½ä½“
setup_agent = Agent(
    name="Setup Agent",
    instructions="""
    Initialize new customer accounts.

    Tasks:
    1. Create default workspace
    2. Set up first project template
    3. Configure notification preferences
    4. Invite team members (if provided)
    5. Connect integrations (if requested)

    Use customer's industry to customize templates.
    """,
    tools=[
        create_workspace,
        create_project_from_template,
        send_team_invites,
        setup_integrations
    ]
)

# 3. åŸ¹è®­æ™ºèƒ½ä½“
training_agent = Agent(
    name="Training Agent",
    instructions="""
    Provide personalized training based on user role and goals.

    Training paths:
    - Project Manager: Focus on planning, timelines, reporting
    - Developer: Focus on task management, Git integration
    - Designer: Focus on file management, feedback tools

    Delivery methods:
    - Interactive in-app tutorial
    - Short video clips (2-3 min)
    - Quick reference cards
    - Practice tasks with feedback

    Track progress and adapt difficulty.
    """,
    tools=[
        show_interactive_tutorial,
        send_training_video,
        create_practice_task,
        track_completion
    ]
)

# 4. ä¸»åŠ¨æ”¯æŒæ™ºèƒ½ä½“
support_agent = Agent(
    name="Proactive Support",
    instructions="""
    Monitor new customers and provide proactive help.

    Triggers:
    - User stuck on same page > 2 minutes â†’ Offer help
    - Failed action > 3 times â†’ Show guide
    - No activity for 2 days â†’ Send encouragement email
    - First milestone reached â†’ Celebrate & suggest next step

    Tone: Friendly, non-intrusive, empowering
    """,
    tools=[
        detect_user_struggle,
        send_contextual_help,
        send_email,
        schedule_followup
    ]
)

# æ‰§è¡Œ
async def onboard_customer(customer_data):
    result = await Runner.run(
        onboarding_orchestrator,
        f"Onboard new customer: {customer_data}"
    )
    return result

# ä½¿ç”¨ç¤ºä¾‹
customer = {
    "name": "Alice Johnson",
    "email": "alice@startup.com",
    "company": "Tech Startup",
    "role": "Product Manager",
    "team_size": 15,
    "industry": "SaaS",
    "goals": ["Launch new feature", "Improve team collaboration"]
}

await onboard_customer(customer)
```

#### ç»“æœ

- âœ… å…¥é—¨æ—¶é—´ï¼šå¹³å‡4å°æ—¶ â†’ 1.2å°æ—¶ï¼ˆå‡å°‘70%ï¼‰
- âœ… æ´»è·ƒç”¨æˆ·è½¬åŒ–ç‡ï¼š35% â†’ 68%
- âœ… ç¬¬ä¸€å‘¨äº§å“é‡‡ç”¨ç‡ï¼š52% â†’ 89%
- âœ… æ”¯æŒå·¥å•ï¼šå…¥é—¨ç›¸å…³å·¥å•å‡å°‘83%

---

### æ¡ˆä¾‹2ï¼šæ•°æ®ç®¡é“è‡ªåŠ¨åŒ–

<strong>ä¼ä¸š</strong>ï¼šç”µå­å•†åŠ¡å¹³å°
<strong>ç›®æ ‡</strong>ï¼šETLç®¡é“æ•…éšœè‡ªåŠ¨æ¢å¤

#### å®ç°ä»£ç 

```python
from agents import Agent, Runner
import asyncio

# 1. æ•°æ®ç›‘æ§æ™ºèƒ½ä½“
monitor_agent = Agent(
    name="Pipeline Monitor",
    instructions="""
    Monitor data pipeline health 24/7.

    Check:
    - Data freshness (< 15 min lag)
    - Row count anomalies (Â±20% from expected)
    - Schema changes
    - Failed jobs

    On anomaly: Alert and delegate to Troubleshooter.
    """,
    tools=[
        check_pipeline_status,
        calculate_data_lag,
        detect_anomalies,
        send_alert
    ],
    handoffs=["Troubleshooter Agent"]
)

# 2. æ•…éšœæ’é™¤æ™ºèƒ½ä½“
troubleshooter_agent = Agent(
    name="Troubleshooter Agent",
    instructions="""
    Diagnose and fix pipeline issues.

    Diagnostic process:
    1. Check logs for error patterns
    2. Verify source data availability
    3. Test connections
    4. Check resource usage (CPU, memory)

    Auto-fix if possible:
    - Restart failed jobs
    - Clear stale locks
    - Retry with backoff

    Escalate if:
    - Schema incompatibility
    - Source system down
    - Data corruption
    """,
    tools=[
        read_logs,
        restart_job,
        clear_locks,
        test_connection,
        check_resources
    ],
    handoffs=["Engineer On-Call"]
)

# 3. å®æ—¶ç›‘æ§å¾ªç¯
async def monitor_pipeline():
    while True:
        result = await Runner.run(
            monitor_agent,
            "Check pipeline health"
        )

        if result.status == "anomaly_detected":
            # å¼€å§‹è‡ªåŠ¨æ•…éšœæ’é™¤
            fix_result = await Runner.run(
                troubleshooter_agent,
                f"Fix issue: {result.anomaly_description}"
            )

            if fix_result.status == "fixed":
                print(f"âœ… è‡ªåŠ¨æ¢å¤å®Œæˆ: {fix_result.action_taken}")
            else:
                print(f"âš ï¸ éœ€è¦äººå·¥ä»‹å…¥: {fix_result.escalation_reason}")

        await asyncio.sleep(60)  # æ¯åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡

# æ‰§è¡Œ
asyncio.run(monitor_pipeline())
```

#### ç»“æœ

- âœ… å¹³å‡æ¢å¤æ—¶é—´ï¼ˆMTTRï¼‰ï¼š45åˆ†é’Ÿ â†’ 8åˆ†é’Ÿï¼ˆå‡å°‘82%ï¼‰
- âœ… è‡ªåŠ¨æ¢å¤ç‡ï¼š78%ï¼ˆæ— éœ€äººå·¥ä»‹å…¥å³å¯è§£å†³ï¼‰
- âœ… å¹´åº¦åœæœºæ—¶é—´ï¼š120å°æ—¶ â†’ 22å°æ—¶
- âœ… å·¥ç¨‹å¸ˆå¾…å‘½æ—¶é—´ï¼šæ¯å‘¨15å°æ—¶ â†’ 3å°æ—¶

---

### æ¡ˆä¾‹3ï¼šDevOpså·¥ä½œæµè‡ªåŠ¨åŒ–

<strong>ä¼ä¸š</strong>ï¼šé‡‘èç§‘æŠ€åˆåˆ›å…¬å¸
<strong>ç›®æ ‡</strong>ï¼šéƒ¨ç½²æµç¨‹å®Œå…¨è‡ªåŠ¨åŒ–ï¼Œé›¶æ‰‹åŠ¨æ“ä½œ

#### å®Œå…¨è‡ªåŠ¨åŒ–çš„éƒ¨ç½²ç®¡é“

```python
from agents import Agent, Runner

# 1. PRå®¡æŸ¥è€…
pr_reviewer = Agent(
    name="PR Reviewer",
    instructions="""
    Review pull requests for:
    - Code quality
    - Security vulnerabilities
    - Performance implications
    - Test coverage (>80%)
    - Breaking changes

    Auto-approve if all checks pass.
    Request changes if issues found.
    """,
    tools=[run_linter, run_security_scan, check_test_coverage],
    handoffs=["Human Reviewer"]  # ä»…å¤æ‚æƒ…å†µ
)

# 2. æµ‹è¯•åè°ƒå™¨
test_orchestrator = Agent(
    name="Test Orchestrator",
    instructions="""
    Run comprehensive test suite:
    1. Unit tests (parallel)
    2. Integration tests
    3. E2E tests (critical paths)
    4. Performance tests
    5. Security tests

    On failure: Auto-bisect to find breaking commit.
    """,
    tools=[
        run_unit_tests,
        run_integration_tests,
        run_e2e_tests,
        run_performance_tests,
        bisect_commits
    ]
)

# 3. éƒ¨ç½²æ™ºèƒ½ä½“
deployer = Agent(
    name="Deployment Agent",
    instructions="""
    Progressive deployment strategy:
    1. Deploy to canary (1% traffic)
    2. Monitor for 10 minutes
    3. If healthy: 25% traffic
    4. If healthy: 50% traffic
    5. If healthy: 100% traffic

    Rollback if:
    - Error rate > 1%
    - Latency increase > 20%
    - Custom metrics degradation

    Post-deployment:
    - Update changelog
    - Notify team on Slack
    - Create Datadog dashboard
    """,
    tools=[
        deploy_canary,
        check_health_metrics,
        rollback,
        update_changelog,
        send_slack_notification
    ]
)

# 4. å®Œæ•´ç®¡é“
async def automated_deploy(pr_number):
    # é˜¶æ®µ1ï¼šä»£ç å®¡æŸ¥
    review = await Runner.run(pr_reviewer, f"Review PR #{pr_number}")
    if not review.approved:
        return {"status": "blocked", "reason": review.feedback}

    # é˜¶æ®µ2ï¼šæµ‹è¯•
    tests = await Runner.run(test_orchestrator, f"Test PR #{pr_number}")
    if not tests.passed:
        return {"status": "failed", "failing_tests": tests.failures}

    # é˜¶æ®µ3ï¼šéƒ¨ç½²
    deployment = await Runner.run(deployer, f"Deploy PR #{pr_number}")
    return deployment

# ä½¿ç”¨
result = await automated_deploy(pr_number=1234)
```

#### ç»“æœ

- âœ… éƒ¨ç½²é¢‘ç‡ï¼šæ¯å‘¨2æ¬¡ â†’ æ¯å¤©5æ¬¡
- âœ… éƒ¨ç½²å¤±è´¥ç‡ï¼š12% â†’ 0.8%
- âœ… å›æ»šæ—¶é—´ï¼š20åˆ†é’Ÿ â†’ 2åˆ†é’Ÿï¼ˆè‡ªåŠ¨ï¼‰
- âœ… å·¥ç¨‹å¸ˆæ—¶é—´èŠ‚çœï¼šæ¯å‘¨40å°æ—¶

---

## é«˜çº§æ€§èƒ½ä¼˜åŒ–æŠ€æœ¯

### 1. å¹¶è¡Œå¤„ç†æ¨¡å¼

```python
import asyncio
from agents import Agent, Runner

# å¹¶è¡Œè¿è¡Œå¤šä¸ªæ™ºèƒ½ä½“
async def parallel_execution():
    agents = [research_agent, analysis_agent, writing_agent]
    tasks = [
        Runner.run(research_agent, "Research topic A"),
        Runner.run(analysis_agent, "Analyze data B"),
        Runner.run(writing_agent, "Write summary C")
    ]

    # å¹¶è¡Œæ‰§è¡Œï¼ˆåŒæ—¶å¯åŠ¨ï¼‰
    results = await asyncio.gather(*tasks)
    return results

# é¡ºåºæ‰§è¡Œï¼š9ç§’ï¼ˆæ¯ä¸ª3ç§’ï¼‰
# å¹¶è¡Œæ‰§è¡Œï¼š3ç§’ï¼ˆæå‡67%ï¼ï¼‰
```

### 2. æµå¼å“åº”

```python
from agents import Agent, Runner

agent = Agent(name="Writer", instructions="...")

# æµå¼æ¨¡å¼
async for chunk in Runner.run_stream(agent, "Write a long article"):
    print(chunk, end="", flush=True)
    # ç«‹å³å‘ç”¨æˆ·å±•ç¤ºï¼ˆæ”¹å–„UXï¼‰
```

### 3. æ‰¹å¤„ç†

```python
# æ‰¹é‡å¤„ç†å¤šä¸ªè¯·æ±‚
async def batch_process(requests: list):
    # æ¯æ¬¡å¤„ç†10ä¸ªï¼ˆAPIä¼˜åŒ–ï¼‰
    batch_size = 10
    results = []

    for i in range(0, len(requests), batch_size):
        batch = requests[i:i+batch_size]
        batch_results = await Runner.run_batch(agent, batch)
        results.extend(batch_results)

    return results

# 1000ä¸ªè¯·æ±‚ï¼šå•ç‹¬å¤„ç†100ç§’ â†’ æ‰¹å¤„ç†15ç§’
```

---

## ä¸‹ä¸€æ­¥

æ‚¨å·²ç»æŒæ¡äº†AgentKitï¼ç°åœ¨å¯ä»¥æ„å»ºè‡ªå·±çš„ç”Ÿäº§ç³»ç»Ÿäº†ã€‚

### æ¨èå­¦ä¹ è·¯å¾„

1. <strong>ä»å°åšèµ·</strong>ï¼šç”¨1ã€œ2ä¸ªæ™ºèƒ½ä½“æ„å»ºç®€å•å·¥ä½œæµ
2. <strong>æµ‹é‡</strong>ï¼šä½¿ç”¨Evalsè¿½è¸ªæ€§èƒ½
3. <strong>è¿­ä»£</strong>ï¼šé€šè¿‡A/Bæµ‹è¯•æŒç»­æ”¹è¿›
4. <strong>æ‰©å±•</strong>ï¼šæ·»åŠ æ›´å¤šæ™ºèƒ½ä½“å’Œå¤æ‚æ¨¡å¼
5. <strong>ä¼˜åŒ–</strong>ï¼šåº”ç”¨å¹¶è¡Œå¤„ç†ã€ç¼“å­˜ã€æµå¼ä¼ è¾“

### ç¤¾åŒºä¸èµ„æº

- <strong>OpenAI DevDay 2025è§†é¢‘</strong>ï¼šæŸ¥çœ‹å®æˆ˜æ¼”ç¤º
- <strong>AgentKit GitHub</strong>ï¼šç¤¾åŒºç¤ºä¾‹å’Œæ¨¡æ¿
- <strong>MCP Hub</strong>ï¼šæ¢ç´¢å„ç§MCPæœåŠ¡å™¨
- <strong>r/OpenAI</strong>ï¼šä¸å…¶ä»–å¼€å‘è€…åˆ†äº«ç»éªŒ

---

<strong>ç³»åˆ—å®Œç»“ï¼</strong> ğŸ‰

ç°åœ¨æ‚¨å·²ç»äº†è§£äº†AgentKitçš„ä¸€åˆ‡ã€‚åœ¨[ç¬¬1éƒ¨](/zh/blog/zh/openai-agentkit-tutorial-part1)å­¦ä¹ äº†åŸºç¡€ï¼Œåœ¨ç¬¬2éƒ¨æŒæ¡äº†å®æˆ˜æŠ€èƒ½ã€‚

å¦‚æœ‰ä»»ä½•é—®é¢˜æˆ–åé¦ˆï¼Œè¯·åœ¨è¯„è®ºä¸­ç•™è¨€ã€‚æœŸå¾…æ‚¨çš„AgentKité¡¹ç›®ï¼
