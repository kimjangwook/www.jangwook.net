---
title: 'OpenAI AgentKit ì™„ë²½ ê°€ì´ë“œ 2ë¶€: ì‹¤ì „ ì ìš©ê³¼ ê³ ê¸‰ íŒ¨í„´'
description: 'ì—”í„°í”„ë¼ì´ì¦ˆê¸‰ ë©€í‹° ì—ì´ì „íŠ¸ ì‹œìŠ¤í…œ ì„¤ê³„ë¶€í„° í”„ë¡œë•ì…˜ ë°°í¬ê¹Œì§€, AgentKit ì‹¤ì „ ë§ˆìŠ¤í„° ê°€ì´ë“œ'
pubDate: '2025-10-21'
heroImage: ../../../assets/blog/openai-agentkit-part2-hero.jpg
tags:
  - OpenAI
  - AgentKit
  - AI Agent
relatedPosts:
  - slug: ai-content-recommendation-system
    score: 0.94
    reason:
      ko: 'ìë™í™”, AI/ML, ì•„í‚¤í…ì²˜ ë¶„ì•¼ì—ì„œ ìœ ì‚¬í•œ ì£¼ì œë¥¼ ë‹¤ë£¨ë©° ë¹„ìŠ·í•œ ë‚œì´ë„ì…ë‹ˆë‹¤.'
      ja: è‡ªå‹•åŒ–ã€AI/MLã€ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£åˆ†é‡ã§é¡ä¼¼ã—ãŸãƒˆãƒ”ãƒƒã‚¯ã‚’æ‰±ã„ã€åŒç¨‹åº¦ã®é›£æ˜“åº¦ã§ã™ã€‚
      en: >-
        Covers similar topics in automation, AI/ML, architecture with comparable
        difficulty.
      zh: åœ¨è‡ªåŠ¨åŒ–ã€AI/MLã€æ¶æ„é¢†åŸŸæ¶µç›–ç±»ä¼¼ä¸»é¢˜ï¼Œéš¾åº¦ç›¸å½“ã€‚
  - slug: google-analytics-mcp-automation
    score: 0.94
    reason:
      ko: 'ìë™í™”, AI/ML, DevOps, ì•„í‚¤í…ì²˜ ë¶„ì•¼ì—ì„œ ìœ ì‚¬í•œ ì£¼ì œë¥¼ ë‹¤ë£¨ë©° ë¹„ìŠ·í•œ ë‚œì´ë„ì…ë‹ˆë‹¤.'
      ja: è‡ªå‹•åŒ–ã€AI/MLã€DevOpsã€ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£åˆ†é‡ã§é¡ä¼¼ã—ãŸãƒˆãƒ”ãƒƒã‚¯ã‚’æ‰±ã„ã€åŒç¨‹åº¦ã®é›£æ˜“åº¦ã§ã™ã€‚
      en: >-
        Covers similar topics in automation, AI/ML, DevOps, architecture with
        comparable difficulty.
      zh: åœ¨è‡ªåŠ¨åŒ–ã€AI/MLã€DevOpsã€æ¶æ„é¢†åŸŸæ¶µç›–ç±»ä¼¼ä¸»é¢˜ï¼Œéš¾åº¦ç›¸å½“ã€‚
  - slug: specification-driven-development
    score: 0.94
    reason:
      ko: 'ìë™í™”, AI/ML, ì•„í‚¤í…ì²˜ ë¶„ì•¼ì—ì„œ ìœ ì‚¬í•œ ì£¼ì œë¥¼ ë‹¤ë£¨ë©° ë¹„ìŠ·í•œ ë‚œì´ë„ì…ë‹ˆë‹¤.'
      ja: è‡ªå‹•åŒ–ã€AI/MLã€ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£åˆ†é‡ã§é¡ä¼¼ã—ãŸãƒˆãƒ”ãƒƒã‚¯ã‚’æ‰±ã„ã€åŒç¨‹åº¦ã®é›£æ˜“åº¦ã§ã™ã€‚
      en: >-
        Covers similar topics in automation, AI/ML, architecture with comparable
        difficulty.
      zh: åœ¨è‡ªåŠ¨åŒ–ã€AI/MLã€æ¶æ„é¢†åŸŸæ¶µç›–ç±»ä¼¼ä¸»é¢˜ï¼Œéš¾åº¦ç›¸å½“ã€‚
  - slug: metadata-based-recommendation-optimization
    score: 0.93
    reason:
      ko: 'ìë™í™”, AI/ML, DevOps, ì•„í‚¤í…ì²˜ ë¶„ì•¼ì—ì„œ ìœ ì‚¬í•œ ì£¼ì œë¥¼ ë‹¤ë£¨ë©° ë¹„ìŠ·í•œ ë‚œì´ë„ì…ë‹ˆë‹¤.'
      ja: è‡ªå‹•åŒ–ã€AI/MLã€DevOpsã€ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£åˆ†é‡ã§é¡ä¼¼ã—ãŸãƒˆãƒ”ãƒƒã‚¯ã‚’æ‰±ã„ã€åŒç¨‹åº¦ã®é›£æ˜“åº¦ã§ã™ã€‚
      en: >-
        Covers similar topics in automation, AI/ML, DevOps, architecture with
        comparable difficulty.
      zh: åœ¨è‡ªåŠ¨åŒ–ã€AI/MLã€DevOpsã€æ¶æ„é¢†åŸŸæ¶µç›–ç±»ä¼¼ä¸»é¢˜ï¼Œéš¾åº¦ç›¸å½“ã€‚
  - slug: ai-agent-collaboration-patterns
    score: 0.92
    reason:
      ko: 'ë‹¤ìŒ ë‹¨ê³„ í•™ìŠµìœ¼ë¡œ ì í•©í•˜ë©°, ìë™í™”, AI/ML, ì•„í‚¤í…ì²˜ ì£¼ì œì—ì„œ ì—°ê²°ë©ë‹ˆë‹¤.'
      ja: æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—ã®å­¦ç¿’ã«é©ã—ã¦ãŠã‚Šã€è‡ªå‹•åŒ–ã€AI/MLã€ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã®ãƒˆãƒ”ãƒƒã‚¯ã§ç¹‹ãŒã‚Šã¾ã™ã€‚
      en: >-
        Suitable as a next-step learning resource, connecting through
        automation, AI/ML, architecture topics.
      zh: é€‚åˆä½œä¸ºä¸‹ä¸€æ­¥å­¦ä¹ èµ„æºï¼Œé€šè¿‡è‡ªåŠ¨åŒ–ã€AI/MLã€æ¶æ„ä¸»é¢˜è¿›è¡Œè¿æ¥ã€‚
---

> <strong>ì‹œë¦¬ì¦ˆ: OpenAI AgentKit ë§ˆìŠ¤í„°í•˜ê¸°</strong> (2/2)
>
> 1. [OpenAI AgentKit ì™„ë²½ ê°€ì´ë“œ 1ë¶€: í•µì‹¬ ê°œë…ê³¼ ì‹œì‘í•˜ê¸°](/ko/blog/ko/openai-agentkit-tutorial-part1)
> 2. <strong>OpenAI AgentKit ì™„ë²½ ê°€ì´ë“œ 2ë¶€: ì‹¤ì „ ì ìš©ê³¼ ê³ ê¸‰ íŒ¨í„´</strong> â† í˜„ì¬ ê¸€

# OpenAI AgentKit ì™„ë²½ ê°€ì´ë“œ 2ë¶€: ì‹¤ì „ ì ìš©ê³¼ ê³ ê¸‰ íŒ¨í„´

[1ë¶€](/ko/blog/ko/openai-agentkit-tutorial-part1)ì—ì„œ AgentKitì˜ í•µì‹¬ ê°œë…ê³¼ ê¸°ë³¸ ì‚¬ìš©ë²•ì„ ë°°ì› ìŠµë‹ˆë‹¤. ì´ì œ ì‹¤ì œ í”„ë¡œë•ì…˜ í™˜ê²½ì—ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” <strong>ê³ ê¸‰ ì•„í‚¤í…ì²˜ íŒ¨í„´</strong>ê³¼ <strong>ì—”í„°í”„ë¼ì´ì¦ˆê¸‰ ì‹œìŠ¤í…œ ì„¤ê³„</strong>ë¥¼ ë‹¤ë£¹ë‹ˆë‹¤.

ì´ ê¸€ì—ì„œëŠ” ì‹¤ì œ ê¸°ì—…ë“¤ì´ ì–´ë–»ê²Œ AgentKitì„ í™œìš©í•˜ì—¬ ë³µì¡í•œ ë¬¸ì œë¥¼ í•´ê²°í•˜ëŠ”ì§€, ê·¸ë¦¬ê³  ì—¬ëŸ¬ë¶„ì´ ì§ì ‘ êµ¬í˜„í•  ìˆ˜ ìˆëŠ” <strong>ì™„ì „í•œ ì½”ë“œ ì˜ˆì œ</strong>ë¥¼ ì œê³µí•©ë‹ˆë‹¤.

## í•µì‹¬ ìš”ì•½ (TL;DR)

- ğŸ—ï¸ <strong>3ê°€ì§€ ì—”í„°í”„ë¼ì´ì¦ˆ ì•„í‚¤í…ì²˜ íŒ¨í„´</strong>: ê³„ì¸µì , ì´ë²¤íŠ¸ ì£¼ë„, ê·¸ë˜í”„ ê¸°ë°˜ ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´ì…˜
- ğŸ”§ <strong>ì»¤ìŠ¤í…€ MCP ì„œë²„ êµ¬ì¶•</strong>: ì§ì ‘ ë§Œë“¤ì–´ AgentKitì— í†µí•©
- ğŸ“Š <strong>í”„ë¡œë•ì…˜ ëª¨ë‹ˆí„°ë§</strong>: Evalsë¥¼ í™œìš©í•œ ì„±ëŠ¥ ìµœì í™” ë° A/B í…ŒìŠ¤íŠ¸
- ğŸ›¡ï¸ <strong>ì—”í„°í”„ë¼ì´ì¦ˆ ë³´ì•ˆ</strong>: ë°ì´í„° ê²©ë¦¬, ê°ì‚¬ ë¡œê·¸, ì»´í”Œë¼ì´ì–¸ìŠ¤
- ğŸ’¼ <strong>3ê°€ì§€ ì‹¤ì „ ì¼€ì´ìŠ¤</strong>: SaaS ìë™í™”, ë°ì´í„° íŒŒì´í”„ë¼ì¸, DevOps ì›Œí¬í”Œë¡œìš°
- âš¡ <strong>ì„±ëŠ¥ ìµœì í™”</strong>: ë³‘ë ¬ ì²˜ë¦¬, ìºì‹±, ìŠ¤íŠ¸ë¦¬ë° ì‘ë‹µ

## ì—”í„°í”„ë¼ì´ì¦ˆ ì•„í‚¤í…ì²˜ íŒ¨í„´

### íŒ¨í„´ 1: ê³„ì¸µì  ê´€ë¦¬ì-ì‘ì—…ì (Hierarchical Manager-Worker)

<strong>ì‚¬ìš© ì‹œë‚˜ë¦¬ì˜¤</strong>: ë³µì¡í•œ ì˜ì‚¬ê²°ì • íŠ¸ë¦¬, ëª…í™•í•œ ì±…ì„ ë¶„ë¦¬ê°€ í•„ìš”í•œ ê²½ìš°

```mermaid
graph TD
    Manager[Manager Agent<br/>ì˜ì‚¬ê²°ì • & ê³„íš] --> Worker1[Frontend Specialist<br/>UI/UX êµ¬í˜„]
    Manager --> Worker2[Backend Specialist<br/>API & DB]
    Manager --> Worker3[DevOps Specialist<br/>ë°°í¬ & ëª¨ë‹ˆí„°ë§]

    Worker2 --> SubWorker1[Database Expert<br/>ìŠ¤í‚¤ë§ˆ ì„¤ê³„]
    Worker2 --> SubWorker2[API Expert<br/>ì—”ë“œí¬ì¸íŠ¸ ì„¤ê³„]

    Worker1 -.->|ë³´ê³ | Manager
    Worker2 -.->|ë³´ê³ | Manager
    Worker3 -.->|ë³´ê³ | Manager

    style Manager fill:#10A37F
    style Worker1 fill:#FFB800
    style Worker2 fill:#FFB800
    style Worker3 fill:#FFB800
```

#### êµ¬í˜„ ì˜ˆì œ: í’€ìŠ¤íƒ ì•± ìƒì„± ì‹œìŠ¤í…œ

```python
from agents import Agent, Runner

# 1. ë§¤ë‹ˆì € ì—ì´ì „íŠ¸ (ìµœìƒìœ„)
manager = Agent(
    name="Project Manager",
    instructions="""
    You are a technical project manager for building web applications.

    Your responsibilities:
    1. Analyze user requirements
    2. Break down into tasks
    3. Delegate to specialist agents
    4. Coordinate between teams
    5. Ensure quality standards
    6. Report progress

    Decision framework:
    - Frontend tasks â†’ Frontend Specialist
    - Backend/API tasks â†’ Backend Specialist
    - Database tasks â†’ Backend Specialist (who delegates to Database Expert)
    - Deployment tasks â†’ DevOps Specialist

    Always verify feasibility before delegation.
    """,
    handoffs=[
        "Frontend Specialist",
        "Backend Specialist",
        "DevOps Specialist"
    ]
)

# 2. í”„ë¡ íŠ¸ì—”ë“œ ì „ë¬¸ê°€
frontend_specialist = Agent(
    name="Frontend Specialist",
    instructions="""
    You specialize in frontend development.

    Skills:
    - React/Next.js component design
    - Tailwind CSS styling
    - Responsive layouts
    - Form validation
    - State management

    When you receive a task:
    1. Design component structure
    2. Implement with best practices
    3. Ensure accessibility (WCAG)
    4. Test on multiple screen sizes
    5. Report completion to Project Manager
    """,
    tools=[create_component, add_styling, validate_accessibility],
    handoffs=["Project Manager"]
)

# 3. ë°±ì—”ë“œ ì „ë¬¸ê°€
backend_specialist = Agent(
    name="Backend Specialist",
    instructions="""
    You specialize in backend development.

    Skills:
    - RESTful API design
    - Database schema design
    - Authentication/authorization
    - Error handling
    - Performance optimization

    For complex database tasks, delegate to Database Expert.
    For API design, handle directly.
    """,
    tools=[create_api_endpoint, design_schema],
    handoffs=["Database Expert", "Project Manager"]
)

# 4. ë°ì´í„°ë² ì´ìŠ¤ ì „ë¬¸ê°€ (í•˜ìœ„ ì „ë¬¸ê°€)
database_expert = Agent(
    name="Database Expert",
    instructions="""
    You are a database specialist.

    Expertise:
    - PostgreSQL, MongoDB, Redis
    - Index optimization
    - Query performance tuning
    - Migration strategies
    - Backup/recovery

    Always consider:
    - Data integrity constraints
    - Scalability
    - Query performance
    - Migration path
    """,
    tools=[create_migration, optimize_query, add_index],
    handoffs=["Backend Specialist"]
)

# 5. DevOps ì „ë¬¸ê°€
devops_specialist = Agent(
    name="DevOps Specialist",
    instructions="""
    You handle deployment and infrastructure.

    Responsibilities:
    - CI/CD pipeline setup
    - Docker containerization
    - Kubernetes deployment
    - Monitoring setup
    - Security hardening

    Follow the 12-factor app principles.
    """,
    tools=[create_dockerfile, setup_ci_cd, deploy_to_k8s],
    handoffs=["Project Manager"]
)
```

#### ì‹¤í–‰ ì˜ˆì œ

```python
# ì‚¬ìš©ì ìš”ì²­
user_request = """
Create a task management SaaS application with:
- User authentication
- Task CRUD operations
- Real-time updates
- Dashboard with analytics
- Mobile responsive
- Deploy to production
"""

# ë§¤ë‹ˆì €ê°€ ì „ì²´ í”„ë¡œì íŠ¸ ì¡°ìœ¨
result = Runner.run_sync(
    manager,
    user_request
)

# ì‹¤í–‰ íë¦„:
# 1. Manager: ìš”êµ¬ì‚¬í•­ ë¶„ì„ & ì‘ì—… ë¶„í•´
# 2. Manager â†’ Frontend Specialist: UI ì»´í¬ë„ŒíŠ¸ ìƒì„±
# 3. Manager â†’ Backend Specialist: API ì„¤ê³„
# 4. Backend Specialist â†’ Database Expert: ìŠ¤í‚¤ë§ˆ ì„¤ê³„
# 5. Database Expert â†’ Backend Specialist: ì™„ë£Œ ë³´ê³ 
# 6. Backend Specialist â†’ Manager: ì™„ë£Œ ë³´ê³ 
# 7. Manager â†’ DevOps Specialist: ë°°í¬
# 8. DevOps Specialist â†’ Manager: ë°°í¬ ì™„ë£Œ
# 9. Manager â†’ User: í”„ë¡œì íŠ¸ ì™„ë£Œ ë¦¬í¬íŠ¸
```

<strong>ì¥ì </strong>:
- ëª…í™•í•œ ì±…ì„ ë¶„ë¦¬
- í™•ì¥ ê°€ëŠ¥ (ìƒˆ ì „ë¬¸ê°€ ì¶”ê°€ ìš©ì´)
- ë””ë²„ê¹… ìš©ì´ (ê³„ì¸µë³„ ì¶”ì )
- ë¦¬ì†ŒìŠ¤ íš¨ìœ¨ì  (í•„ìš”í•œ ì „ë¬¸ê°€ë§Œ í˜¸ì¶œ)

<strong>ë‹¨ì </strong>:
- ë§¤ë‹ˆì €ê°€ ë³‘ëª©ì ì´ ë  ìˆ˜ ìˆìŒ
- ê³„ì¸µì´ ê¹Šìœ¼ë©´ ì§€ì—° ì¦ê°€
- ë§¤ë‹ˆì €ì˜ ì˜ì‚¬ê²°ì • í’ˆì§ˆì— ì˜ì¡´

---

### íŒ¨í„´ 2: ì´ë²¤íŠ¸ ì£¼ë„ ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´ì…˜ (Event-Driven Orchestration)

<strong>ì‚¬ìš© ì‹œë‚˜ë¦¬ì˜¤</strong>: ë¹„ë™ê¸° ì‘ì—…, ëŠìŠ¨í•œ ê²°í•©, ë™ì  ì›Œí¬í”Œë¡œìš°

```mermaid
graph LR
    Event[Event Bus<br/>Message Queue]

    A1[Agent A<br/>ì´ë²¤íŠ¸ ë°œí–‰] -->|event_type: user_created| Event
    Event -->|êµ¬ë…| A2[Agent B<br/>ì´ë©”ì¼ ë°œì†¡]
    Event -->|êµ¬ë…| A3[Agent C<br/>í”„ë¡œí•„ ìƒì„±]
    Event -->|êµ¬ë…| A4[Agent D<br/>ë¶„ì„ ë¡œê·¸]

    A2 -->|event: email_sent| Event
    A3 -->|event: profile_created| Event

    Event -->|êµ¬ë…| A5[Agent E<br/>ì˜¨ë³´ë”© ì‹œì‘]

    style Event fill:#10A37F
    style A1 fill:#FFB800
    style A2 fill:#6C63FF
    style A3 fill:#6C63FF
    style A4 fill:#6C63FF
    style A5 fill:#FF6584
```

#### êµ¬í˜„ ì˜ˆì œ: ì‚¬ìš©ì ì˜¨ë³´ë”© ìë™í™”

```python
from agents import Agent
import asyncio
from typing import Dict, List

class EventBus:
    def __init__(self):
        self.subscribers: Dict[str, List[Agent]] = {}

    def subscribe(self, event_type: str, agent: Agent):
        """ì—ì´ì „íŠ¸ë¥¼ íŠ¹ì • ì´ë²¤íŠ¸ì— êµ¬ë…"""
        if event_type not in self.subscribers:
            self.subscribers[event_type] = []
        self.subscribers[event_type].append(agent)

    async def publish(self, event_type: str, data: dict):
        """ì´ë²¤íŠ¸ ë°œí–‰ ë° ëª¨ë“  êµ¬ë…ìì—ê²Œ ì „ë‹¬"""
        if event_type in self.subscribers:
            tasks = []
            for agent in self.subscribers[event_type]:
                task = Runner.run(agent, f"Handle event: {event_type}\nData: {data}")
                tasks.append(task)

            # ë³‘ë ¬ ì‹¤í–‰
            results = await asyncio.gather(*tasks, return_exceptions=True)
            return results
        return []

# ì´ë²¤íŠ¸ ë²„ìŠ¤ ì´ˆê¸°í™”
event_bus = EventBus()

# 1. ì‚¬ìš©ì ìƒì„± ì—ì´ì „íŠ¸
user_creator = Agent(
    name="User Creator",
    instructions="""
    Create new user accounts.
    After creating a user, publish a 'user_created' event.
    """,
    tools=[create_user_in_db]
)

# 2. ì´ë©”ì¼ ë°œì†¡ ì—ì´ì „íŠ¸
email_agent = Agent(
    name="Email Sender",
    instructions="""
    Send welcome emails to new users.
    Listen for 'user_created' events.
    After sending, publish 'email_sent' event.
    """,
    tools=[send_welcome_email]
)

# 3. í”„ë¡œí•„ ìƒì„± ì—ì´ì „íŠ¸
profile_agent = Agent(
    name="Profile Creator",
    instructions="""
    Create user profiles with default settings.
    Listen for 'user_created' events.
    After creation, publish 'profile_created' event.
    """,
    tools=[create_default_profile]
)

# 4. ë¶„ì„ ë¡œê¹… ì—ì´ì „íŠ¸
analytics_agent = Agent(
    name="Analytics Logger",
    instructions="""
    Log user creation events for analytics.
    Listen for 'user_created' events.
    No event publication needed.
    """,
    tools=[log_to_analytics]
)

# 5. ì˜¨ë³´ë”© ì—ì´ì „íŠ¸
onboarding_agent = Agent(
    name="Onboarding Coordinator",
    instructions="""
    Start user onboarding flow.
    Wait for both 'email_sent' AND 'profile_created' events.
    Then initiate the onboarding tutorial.
    """,
    tools=[start_onboarding_tutorial]
)

# ì´ë²¤íŠ¸ êµ¬ë… ì„¤ì •
event_bus.subscribe("user_created", email_agent)
event_bus.subscribe("user_created", profile_agent)
event_bus.subscribe("user_created", analytics_agent)
event_bus.subscribe("email_sent", onboarding_agent)
event_bus.subscribe("profile_created", onboarding_agent)

# ì‚¬ìš© ì˜ˆì œ
async def create_new_user(user_data: dict):
    # 1. ì‚¬ìš©ì ìƒì„±
    result = await Runner.run(user_creator, f"Create user: {user_data}")

    # 2. user_created ì´ë²¤íŠ¸ ë°œí–‰ (ë³‘ë ¬ ì‹¤í–‰)
    await event_bus.publish("user_created", {"user_id": result.user_id, **user_data})

    # ì´ë©”ì¼, í”„ë¡œí•„, ë¶„ì„ ë¡œê·¸ ë™ì‹œ ì²˜ë¦¬ë¨
```

<strong>ì¥ì </strong>:
- ì—ì´ì „íŠ¸ ê°„ ëŠìŠ¨í•œ ê²°í•©
- ë³‘ë ¬ ì²˜ë¦¬ë¡œ ì„±ëŠ¥ í–¥ìƒ
- ìƒˆ ê¸°ëŠ¥ ì¶”ê°€ ìš©ì´ (ìƒˆ êµ¬ë…ì ì¶”ê°€ë§Œ)
- ì¥ì•  ê²©ë¦¬ (í•˜ë‚˜ ì‹¤íŒ¨í•´ë„ ë‹¤ë¥¸ ê²ƒ ì˜í–¥ ì—†ìŒ)

<strong>ë‹¨ì </strong>:
- ë””ë²„ê¹… ì–´ë ¤ì›€ (ë¹„ë™ê¸° íë¦„)
- ì´ë²¤íŠ¸ ìˆœì„œ ë³´ì¥ ì–´ë ¤ì›€
- ë³µì¡ë„ ì¦ê°€

---

### íŒ¨í„´ 3: ê·¸ë˜í”„ ê¸°ë°˜ ì›Œí¬í”Œë¡œìš° (Graph-Based Workflow)

<strong>ì‚¬ìš© ì‹œë‚˜ë¦¬ì˜¤</strong>: ë³µì¡í•œ ì¡°ê±´ë¶€ íë¦„, ë£¨í”„, ë™ì  ì˜ì‚¬ê²°ì •

```mermaid
graph TD
    Start[ì‹œì‘] --> Analyze[ìš”êµ¬ì‚¬í•­ ë¶„ì„]
    Analyze --> Design{ì„¤ê³„ ë³µì¡ë„?}

    Design -->|ë‹¨ìˆœ| SimpleImpl[ì§ì ‘ êµ¬í˜„]
    Design -->|ë³µì¡| Research[ì¶”ê°€ ë¦¬ì„œì¹˜]

    Research --> ArchDesign[ì•„í‚¤í…ì²˜ ì„¤ê³„]
    ArchDesign --> Review{ë¦¬ë·° í†µê³¼?}

    Review -->|No| ArchDesign
    Review -->|Yes| Implement[êµ¬í˜„]

    SimpleImpl --> Test[í…ŒìŠ¤íŠ¸]
    Implement --> Test

    Test --> QA{QA í†µê³¼?}
    QA -->|No| Debug[ë””ë²„ê·¸]
    Debug --> Test
    QA -->|Yes| Deploy[ë°°í¬]

    Deploy --> Monitor[ëª¨ë‹ˆí„°ë§]
    Monitor --> Issue{ì´ìŠˆ ë°œê²¬?}
    Issue -->|Yes| Debug
    Issue -->|No| End[ì™„ë£Œ]

    style Start fill:#10A37F
    style End fill:#10A37F
    style Design fill:#FFB800
    style Review fill:#FFB800
    style QA fill:#FFB800
    style Issue fill:#FFB800
```

#### êµ¬í˜„ ì˜ˆì œ: LangGraph í™œìš©

```python
from langgraph.graph import StateGraph, END
from agents import Agent
from typing import TypedDict, Annotated

# 1. ìƒíƒœ ì •ì˜
class ProjectState(TypedDict):
    requirements: str
    design: dict
    code: str
    test_results: dict
    deployment_status: str
    issues: list
    iteration_count: int

# 2. ì—ì´ì „íŠ¸ ì •ì˜
analyzer = Agent(
    name="Requirement Analyzer",
    instructions="Analyze requirements and determine complexity",
    tools=[analyze_complexity]
)

designer = Agent(
    name="System Designer",
    instructions="Design system architecture",
    tools=[create_architecture_diagram]
)

implementer = Agent(
    name="Code Implementer",
    instructions="Implement the design in code",
    tools=[write_code, run_linter]
)

tester = Agent(
    name="QA Tester",
    instructions="Test the implementation",
    tools=[run_tests, check_coverage]
)

deployer = Agent(
    name="Deployment Engineer",
    instructions="Deploy to production",
    tools=[deploy_to_prod, setup_monitoring]
)

# 3. ë…¸ë“œ í•¨ìˆ˜ ì •ì˜
async def analyze_node(state: ProjectState) -> ProjectState:
    result = await Runner.run(analyzer, state["requirements"])
    state["design"] = {"complexity": result.complexity, "approach": result.approach}
    return state

async def design_node(state: ProjectState) -> ProjectState:
    result = await Runner.run(designer, f"Design for: {state['design']}")
    state["design"]["architecture"] = result.architecture
    return state

async def implement_node(state: ProjectState) -> ProjectState:
    result = await Runner.run(implementer, f"Implement: {state['design']}")
    state["code"] = result.code
    return state

async def test_node(state: ProjectState) -> ProjectState:
    result = await Runner.run(tester, f"Test: {state['code']}")
    state["test_results"] = result.test_results
    state["issues"] = result.issues
    return state

async def deploy_node(state: ProjectState) -> ProjectState:
    result = await Runner.run(deployer, f"Deploy: {state['code']}")
    state["deployment_status"] = result.status
    return state

# 4. ì¡°ê±´ë¶€ ë¼ìš°íŒ… í•¨ìˆ˜
def should_research(state: ProjectState) -> str:
    if state["design"]["complexity"] == "high":
        return "design"
    return "implement"

def test_passed(state: ProjectState) -> str:
    if state["issues"]:
        if state["iteration_count"] < 3:
            state["iteration_count"] += 1
            return "implement"  # ì¬êµ¬í˜„
        return "escalate"  # ì¸ê°„ ê°œì…
    return "deploy"

# 5. ê·¸ë˜í”„ êµ¬ì„±
workflow = StateGraph(ProjectState)

# ë…¸ë“œ ì¶”ê°€
workflow.add_node("analyze", analyze_node)
workflow.add_node("design", design_node)
workflow.add_node("implement", implement_node)
workflow.add_node("test", test_node)
workflow.add_node("deploy", deploy_node)

# ì—£ì§€ ì¶”ê°€
workflow.set_entry_point("analyze")
workflow.add_conditional_edges(
    "analyze",
    should_research,
    {"design": "design", "implement": "implement"}
)
workflow.add_edge("design", "implement")
workflow.add_edge("implement", "test")
workflow.add_conditional_edges(
    "test",
    test_passed,
    {"deploy": "deploy", "implement": "implement", "escalate": END}
)
workflow.add_edge("deploy", END)

# 6. ì»´íŒŒì¼ ë° ì‹¤í–‰
app = workflow.compile()

# ì‚¬ìš©
initial_state = {
    "requirements": "Build a real-time chat application with video calls",
    "design": {},
    "code": "",
    "test_results": {},
    "deployment_status": "",
    "issues": [],
    "iteration_count": 0
}

final_state = await app.ainvoke(initial_state)
```

<strong>ì¥ì </strong>:
- ë³µì¡í•œ ì¡°ê±´ë¶€ ë¡œì§ í‘œí˜„
- ë£¨í”„ ë° ì¬ì‹œë„ ì§€ì›
- ì‹œê°í™” ê°€ëŠ¥ (ê·¸ë˜í”„ë¡œ í‘œí˜„)
- ë™ì  ì›Œí¬í”Œë¡œìš° ë³€ê²½

<strong>ë‹¨ì </strong>:
- ì´ˆê¸° ì„¤ì • ë³µì¡
- ìƒíƒœ ê´€ë¦¬ í•„ìš”
- LangGraph ì˜ì¡´ì„±

---

## ì»¤ìŠ¤í…€ MCP ì„œë²„ êµ¬ì¶•

MCP(Model Context Protocol)ë¥¼ ì‚¬ìš©í•˜ë©´ AgentKitì„ ì™¸ë¶€ ì‹œìŠ¤í…œê³¼ í‘œì¤€í™”ëœ ë°©ì‹ìœ¼ë¡œ ì—°ê²°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

### ì‹¤ì „ ì˜ˆì œ: Slack MCP ì„œë²„ êµ¬ì¶•

<strong>ëª©í‘œ</strong>: AgentKit ì—ì´ì „íŠ¸ê°€ Slackì— ë©”ì‹œì§€ë¥¼ ë³´ë‚´ê³ , ì±„ë„ì„ ê´€ë¦¬í•˜ê³ , ë°˜ì‘ì„ ì¶”ê°€í•  ìˆ˜ ìˆë„ë¡ í•˜ê¸°

#### 1. MCP ì„œë²„ êµ¬ì¡°

```python
# slack_mcp_server.py
from mcp.server import Server, Tool
from slack_sdk import WebClient
from slack_sdk.errors import SlackApiError
import os

class SlackMCPServer(Server):
    def __init__(self):
        super().__init__(name="slack", version="1.0.0")
        self.client = WebClient(token=os.environ["SLACK_BOT_TOKEN"])

        # ë„êµ¬ ë“±ë¡
        self.register_tool(self.send_message)
        self.register_tool(self.create_channel)
        self.register_tool(self.add_reaction)
        self.register_tool(self.get_channel_history)

    @Tool(
        name="send_message",
        description="Send a message to a Slack channel",
        parameters={
            "channel": {
                "type": "string",
                "description": "Channel ID or name (e.g., '#general')"
            },
            "text": {
                "type": "string",
                "description": "Message text"
            },
            "thread_ts": {
                "type": "string",
                "description": "Thread timestamp (optional, for replies)",
                "optional": True
            }
        }
    )
    async def send_message(self, channel: str, text: str, thread_ts: str = None):
        """Slackì— ë©”ì‹œì§€ ì „ì†¡"""
        try:
            response = self.client.chat_postMessage(
                channel=channel,
                text=text,
                thread_ts=thread_ts
            )
            return {
                "success": True,
                "ts": response["ts"],
                "channel": response["channel"]
            }
        except SlackApiError as e:
            return {
                "success": False,
                "error": str(e)
            }

    @Tool(
        name="create_channel",
        description="Create a new Slack channel",
        parameters={
            "name": {
                "type": "string",
                "description": "Channel name (lowercase, no spaces)"
            },
            "is_private": {
                "type": "boolean",
                "description": "Whether the channel is private",
                "default": False
            }
        }
    )
    async def create_channel(self, name: str, is_private: bool = False):
        """ìƒˆ Slack ì±„ë„ ìƒì„±"""
        try:
            response = self.client.conversations_create(
                name=name,
                is_private=is_private
            )
            return {
                "success": True,
                "channel_id": response["channel"]["id"],
                "channel_name": response["channel"]["name"]
            }
        except SlackApiError as e:
            return {
                "success": False,
                "error": str(e)
            }

    @Tool(
        name="add_reaction",
        description="Add an emoji reaction to a message",
        parameters={
            "channel": {"type": "string", "description": "Channel ID"},
            "timestamp": {"type": "string", "description": "Message timestamp"},
            "name": {"type": "string", "description": "Emoji name (without colons)"}
        }
    )
    async def add_reaction(self, channel: str, timestamp: str, name: str):
        """ë©”ì‹œì§€ì— ì´ëª¨ì§€ ë°˜ì‘ ì¶”ê°€"""
        try:
            self.client.reactions_add(
                channel=channel,
                timestamp=timestamp,
                name=name
            )
            return {"success": True}
        except SlackApiError as e:
            return {"success": False, "error": str(e)}

    @Tool(
        name="get_channel_history",
        description="Get recent messages from a channel",
        parameters={
            "channel": {"type": "string", "description": "Channel ID"},
            "limit": {"type": "integer", "description": "Number of messages", "default": 10}
        }
    )
    async def get_channel_history(self, channel: str, limit: int = 10):
        """ì±„ë„ì˜ ìµœê·¼ ë©”ì‹œì§€ ê°€ì ¸ì˜¤ê¸°"""
        try:
            response = self.client.conversations_history(
                channel=channel,
                limit=limit
            )
            messages = []
            for msg in response["messages"]:
                messages.append({
                    "text": msg.get("text", ""),
                    "user": msg.get("user", ""),
                    "timestamp": msg["ts"]
                })
            return {"success": True, "messages": messages}
        except SlackApiError as e:
            return {"success": False, "error": str(e)}

# ì„œë²„ ì‹¤í–‰
if __name__ == "__main__":
    server = SlackMCPServer()
    server.run(host="localhost", port=3000)
```

#### 2. AgentKitì—ì„œ MCP ì„œë²„ ì‚¬ìš©

```python
from agents import Agent
from agents.mcp import MCPServer

# MCP ì„œë²„ ì—°ê²°
slack_server = MCPServer(
    url="http://localhost:3000",
    name="slack"
)

# Slack ê´€ë¦¬ ì—ì´ì „íŠ¸
slack_agent = Agent(
    name="Slack Manager",
    instructions="""
    You manage Slack communications.

    Capabilities:
    - Send messages to channels
    - Create new channels
    - Add reactions
    - Read channel history

    Best practices:
    - Use threads for related conversations
    - Add emoji reactions to acknowledge messages
    - Create channels with clear, descriptive names
    - Check channel history before sending duplicates
    """,
    mcp_servers=[slack_server]
)

# ì‚¬ìš© ì˜ˆì œ
result = Runner.run_sync(
    slack_agent,
    """
    Create a new channel called 'project-agentkit-updates'.
    Then send a message: "AgentKit integration is now live!ğŸš€"
    Add a thumbs up reaction to confirm.
    """
)
```

#### 3. Connector Registryë¡œ ì—”í„°í”„ë¼ì´ì¦ˆ ê´€ë¦¬

```python
from agents import ConnectorRegistry

# ì¡°ì§ì˜ MCP ì„œë²„ ì¤‘ì•™ ê´€ë¦¬
registry = ConnectorRegistry()

# Slack MCP ë“±ë¡
registry.add_server(
    name="Company Slack",
    mcp_url="http://internal-mcp.company.com/slack",
    permissions=["read", "write"],
    allowed_teams=["engineering", "product", "marketing"],
    rate_limits={"requests_per_minute": 60},
    audit_logging=True
)

# GitHub MCP ë“±ë¡
registry.add_server(
    name="Company GitHub",
    mcp_url="http://internal-mcp.company.com/github",
    permissions=["read", "write"],
    allowed_teams=["engineering"],
    rate_limits={"requests_per_minute": 30},
    require_approval=True  # PR ìƒì„±/ë¨¸ì§€ëŠ” ìŠ¹ì¸ í•„ìš”
)

# ì—ì´ì „íŠ¸ì—ì„œ ë ˆì§€ìŠ¤íŠ¸ë¦¬ ì‚¬ìš©
devops_agent = Agent(
    name="DevOps Automator",
    instructions="Automate DevOps workflows",
    connector_registry=registry
)

# ê¶Œí•œ í™•ì¸ í›„ ì‘ì—… ìˆ˜í–‰
result = Runner.run_sync(
    devops_agent,
    """
    When the build succeeds:
    1. Send a message to #deployments Slack channel
    2. Create a GitHub release
    3. Update the status page
    """
)
```

---

## í”„ë¡œë•ì…˜ ëª¨ë‹ˆí„°ë§ ë° ìµœì í™”

### Evalsë¥¼ í™œìš©í•œ ì„±ëŠ¥ ì¸¡ì •

#### 1. ê¸°ë³¸ ë©”íŠ¸ë¦­ ì¶”ì 

```python
from agents import Evals, Runner

evals = Evals()

# ì—ì´ì „íŠ¸ ì‹¤í–‰ & ìë™ ì¶”ì 
@evals.track(
    agent_name="Customer Support",
    metrics=["latency", "cost", "success_rate", "user_satisfaction"]
)
async def handle_support_ticket(ticket):
    result = await Runner.run(support_agent, ticket)
    return result

# ë©”íŠ¸ë¦­ ì¡°íšŒ
metrics = evals.get_metrics(
    agent_name="Customer Support",
    time_range="last_7_days"
)

print(f"í‰ê·  ì‘ë‹µ ì‹œê°„: {metrics['avg_latency']}ms")
print(f"ì´ ë¹„ìš©: ${metrics['total_cost']}")
print(f"ì„±ê³µë¥ : {metrics['success_rate']}%")
```

#### 2. A/B í…ŒìŠ¤íŠ¸ í”„ë ˆì„ì›Œí¬

```python
from agents import Evals, Agent, Runner
import random

evals = Evals()

# ë‘ ê°€ì§€ í”„ë¡¬í”„íŠ¸ ë²„ì „
prompt_a = """
You are a concise customer support agent.
Answer questions directly and briefly.
"""

prompt_b = """
You are a friendly customer support agent.
Answer questions warmly with examples and explanations.
Use emoji to make responses engaging.
"""

agent_a = Agent(name="Support A", instructions=prompt_a)
agent_b = Agent(name="Support B", instructions=prompt_b)

# A/B í…ŒìŠ¤íŠ¸ ì‹¤í–‰
@evals.ab_test(
    variant_a=agent_a,
    variant_b=agent_b,
    split_ratio=0.5,  # 50/50 ë¶„í• 
    success_metric="user_satisfaction"
)
async def handle_ticket(ticket, user_id):
    # Evalsê°€ ìë™ìœ¼ë¡œ A ë˜ëŠ” Bì— ë¼ìš°íŒ…
    result = await Runner.run(ticket)

    # ì‚¬ìš©ì ë§Œì¡±ë„ ìˆ˜ì§‘
    satisfaction = await get_user_feedback(user_id)
    evals.log_metric("user_satisfaction", satisfaction)

    return result

# 1000ë²ˆ ì‹¤í–‰ í›„ ê²°ê³¼ ë¶„ì„
results = evals.get_ab_test_results(
    test_name="support_prompt_test",
    min_sample_size=500
)

print(f"""
A/B í…ŒìŠ¤íŠ¸ ê²°ê³¼:
Variant A (ê°„ê²°í•œ ìŠ¤íƒ€ì¼):
  - ì‚¬ìš©ì ë§Œì¡±ë„: {results['a']['user_satisfaction']:.2f}/5
  - í‰ê·  ì‘ë‹µ ì‹œê°„: {results['a']['avg_latency']}ms
  - ë¹„ìš©: ${results['a']['avg_cost']}

Variant B (ì¹œê·¼í•œ ìŠ¤íƒ€ì¼):
  - ì‚¬ìš©ì ë§Œì¡±ë„: {results['b']['user_satisfaction']:.2f}/5
  - í‰ê·  ì‘ë‹µ ì‹œê°„: {results['b']['avg_latency']}ms
  - ë¹„ìš©: ${results['b']['avg_cost']}

í†µê³„ì  ìœ ì˜ì„±: p-value = {results['p_value']}
ì¶”ì²œ: Variant {"B" if results['recommendation'] == 'b' else "A"}
""")
```

#### 3. ìë™ í”„ë¡¬í”„íŠ¸ ìµœì í™”

```python
from agents import Evals

evals = Evals()

# ìµœì í™” ëŒ€ìƒ ì—ì´ì „íŠ¸
base_agent = Agent(
    name="Code Reviewer",
    instructions="Review code for bugs and suggest improvements"
)

# ìë™ ìµœì í™” ì‹¤í–‰
optimized_agent = evals.optimize_prompt(
    agent=base_agent,
    optimization_goal="success_rate",  # ë˜ëŠ” "latency", "cost", "user_satisfaction"
    training_data=[
        {"input": "Review this code: ...", "expected_output": "..."},
        # 100ê°œ ì´ìƒì˜ ì˜ˆì œ
    ],
    iterations=50,  # 50ë²ˆ ë°˜ë³µ ì‹¤í—˜
    search_strategy="evolutionary"  # ë˜ëŠ” "grid_search", "bayesian"
)

# ê²°ê³¼ ë¹„êµ
comparison = evals.compare_agents(
    agents=[base_agent, optimized_agent],
    test_data=test_dataset
)

print(f"""
ë² ì´ìŠ¤ë¼ì¸ vs ìµœì í™”:
ì„±ê³µë¥ : {comparison['base']['success_rate']}% â†’ {comparison['optimized']['success_rate']}%
ê°œì„ : +{comparison['improvement']['success_rate']}%
""")
```

---

## ì—”í„°í”„ë¼ì´ì¦ˆ ë³´ì•ˆ ë° ì»´í”Œë¼ì´ì–¸ìŠ¤

### 1. ë°ì´í„° ê²©ë¦¬ (Multi-Tenancy)

```python
from agents import Agent, Session
import hashlib

class TenantIsolatedAgent:
    def __init__(self, base_agent: Agent):
        self.base_agent = base_agent
        self.tenant_sessions = {}

    def get_session(self, tenant_id: str) -> Session:
        """í…Œë„ŒíŠ¸ë³„ ê²©ë¦¬ëœ ì„¸ì…˜"""
        if tenant_id not in self.tenant_sessions:
            # í…Œë„ŒíŠ¸ë³„ ë…ë¦½ì  ì„¸ì…˜ ìƒì„±
            session = Session(
                session_id=self._generate_session_id(tenant_id),
                metadata={"tenant_id": tenant_id},
                isolation_level="tenant"  # ë°ì´í„° ê²©ë¦¬
            )
            self.tenant_sessions[tenant_id] = session
        return self.tenant_sessions[tenant_id]

    async def run(self, tenant_id: str, prompt: str):
        """í…Œë„ŒíŠ¸ ê²©ë¦¬ ì‹¤í–‰"""
        session = self.get_session(tenant_id)

        # í…Œë„ŒíŠ¸ë³„ ê°€ë“œë ˆì¼ ì ìš©
        guardrails = self._get_tenant_guardrails(tenant_id)

        # ì‹¤í–‰
        result = await Runner.run(
            self.base_agent,
            prompt,
            session=session,
            guardrails=guardrails
        )

        # ê°ì‚¬ ë¡œê·¸
        await self._audit_log(tenant_id, prompt, result)

        return result

    def _generate_session_id(self, tenant_id: str) -> str:
        return hashlib.sha256(tenant_id.encode()).hexdigest()

    def _get_tenant_guardrails(self, tenant_id: str):
        # í…Œë„ŒíŠ¸ë³„ ë§ì¶¤ ê°€ë“œë ˆì¼
        return [
            guardrails.no_pii,
            guardrails.tenant_data_access(allowed_tenant=tenant_id),
            guardrails.rate_limit(tenant_id=tenant_id)
        ]

    async def _audit_log(self, tenant_id, prompt, result):
        # ê°ì‚¬ ë¡œê·¸ ê¸°ë¡
        log_entry = {
            "timestamp": datetime.utcnow(),
            "tenant_id": tenant_id,
            "prompt_hash": hashlib.sha256(prompt.encode()).hexdigest(),
            "result_status": result.status,
            "cost": result.cost,
            "latency": result.latency
        }
        await save_audit_log(log_entry)
```

### 2. GDPR/CCPA ì»´í”Œë¼ì´ì–¸ìŠ¤

```python
from agents import guardrails

# PII ê°ì§€ ë° ì²˜ë¦¬ ê°€ë“œë ˆì¼
class PIIComplianceGuardrail(guardrails.Guardrail):
    def __init__(self, region: str = "EU"):
        self.region = region
        self.pii_patterns = {
            "email": r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b',
            "phone": r'\b\d{3}[-.]?\d{3}[-.]?\d{4}\b',
            "ssn": r'\b\d{3}-\d{2}-\d{4}\b',
            "credit_card": r'\b\d{4}[-\s]?\d{4}[-\s]?\d{4}[-\s]?\d{4}\b'
        }

    def validate_input(self, text: str) -> tuple[bool, str]:
        """ì…ë ¥ì—ì„œ PII ê°ì§€"""
        detected_pii = []
        for pii_type, pattern in self.pii_patterns.items():
            if re.search(pattern, text):
                detected_pii.append(pii_type)

        if detected_pii:
            return False, f"PII detected: {', '.join(detected_pii)}. Cannot process."
        return True, ""

    def anonymize_output(self, text: str) -> str:
        """ì¶œë ¥ì—ì„œ PII ìµëª…í™”"""
        for pii_type, pattern in self.pii_patterns.items():
            text = re.sub(pattern, f"[{pii_type.upper()}_REDACTED]", text)
        return text

# ì‚¬ìš©
compliant_agent = Agent(
    name="GDPR Compliant Agent",
    instructions="...",
    input_guardrails=[PIIComplianceGuardrail(region="EU")],
    output_guardrails=[PIIComplianceGuardrail(region="EU")],
    data_retention_days=30,  # GDPR: ë°ì´í„° ë³´ì¡´ ê¸°ê°„
    user_consent_required=True
)
```

### 3. ê°ì‚¬ ë¡œê·¸ ë° ì¶”ì 

```python
from agents import Agent, AuditLogger

# ê°ì‚¬ ë¡œê±° ì„¤ì •
audit_logger = AuditLogger(
    storage="postgresql://audit_db",
    retention_period_days=365,  # 1ë…„ ë³´ì¡´
    fields=[
        "timestamp",
        "user_id",
        "agent_name",
        "input_hash",  # ì‹¤ì œ ì…ë ¥ì€ ì €ì¥ ì•ˆ í•¨ (í”„ë¼ì´ë²„ì‹œ)
        "output_hash",
        "tools_used",
        "cost",
        "latency",
        "guardrail_triggers",
        "handoffs"
    ]
)

# ì—ì´ì „íŠ¸ì— ê°ì‚¬ ë¡œê±° ì—°ê²°
audited_agent = Agent(
    name="Financial Advisor",
    instructions="...",
    audit_logger=audit_logger,
    compliance_mode=True  # ëª¨ë“  í™œë™ ë¡œê¹…
)

# ê°ì‚¬ ë¡œê·¸ ì¡°íšŒ
logs = audit_logger.query(
    user_id="user_12345",
    date_range=("2025-01-01", "2025-01-31"),
    agent_name="Financial Advisor"
)

# ì´ìƒ íƒì§€
anomalies = audit_logger.detect_anomalies(
    metrics=["cost", "latency", "guardrail_triggers"],
    threshold=2.5  # í‰ê· ì—ì„œ 2.5 í‘œì¤€í¸ì°¨ ì´ìƒ
)
```

---

## ì‹¤ì „ ì¼€ì´ìŠ¤ ìŠ¤í„°ë””

### ì¼€ì´ìŠ¤ 1: SaaS ê³ ê° ì˜¨ë³´ë”© ìë™í™”

<strong>ê¸°ì—…</strong>: B2B SaaS (í”„ë¡œì íŠ¸ ê´€ë¦¬ ë„êµ¬)
<strong>ëª©í‘œ</strong>: ì‹ ê·œ ê³ ê° ì˜¨ë³´ë”© ì‹œê°„ 70% ë‹¨ì¶•

#### ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜

```mermaid
sequenceDiagram
    participant User as ì‹ ê·œ ê³ ê°
    participant Onboarding as ì˜¨ë³´ë”© ì—ì´ì „íŠ¸
    participant Setup as ì„¤ì • ì—ì´ì „íŠ¸
    participant Training as êµìœ¡ ì—ì´ì „íŠ¸
    participant Support as ì§€ì› ì—ì´ì „íŠ¸

    User->>Onboarding: ê°€ì… ì™„ë£Œ
    Onboarding->>Setup: ê³„ì • ì´ˆê¸°í™”
    Setup->>Setup: ê¸°ë³¸ í”„ë¡œì íŠ¸ ìƒì„±
    Setup->>Setup: íŒ€ ë©¤ë²„ ì´ˆëŒ€
    Setup-->>Onboarding: ì„¤ì • ì™„ë£Œ

    Onboarding->>Training: ë§ì¶¤í˜• íŠœí† ë¦¬ì–¼ ì‹œì‘
    Training->>User: ë‹¨ê³„ë³„ ê°€ì´ë“œ ì œê³µ
    User->>Training: íŠœí† ë¦¬ì–¼ ì™„ë£Œ
    Training-->>Onboarding: êµìœ¡ ì™„ë£Œ

    Onboarding->>Support: ì²« ì£¼ ì§‘ì¤‘ ì§€ì› í™œì„±í™”
    Support->>User: í”„ë¡œì•¡í‹°ë¸Œ ë„ì›€ë§

    Onboarding->>User: ì˜¨ë³´ë”© ì™„ë£Œ ğŸ‰
```

#### êµ¬í˜„ ì½”ë“œ

```python
from agents import Agent, Runner

# 1. ì˜¨ë³´ë”© ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´í„°
onboarding_orchestrator = Agent(
    name="Onboarding Orchestrator",
    instructions="""
    You coordinate the entire customer onboarding process.

    Steps:
    1. Welcome the customer
    2. Delegate account setup to Setup Agent
    3. Delegate training to Training Agent
    4. Activate proactive support
    5. Schedule follow-ups

    Success criteria:
    - Customer completes 3+ tasks
    - Team invited
    - First project created
    """,
    handoffs=["Setup Agent", "Training Agent", "Support Agent"]
)

# 2. ì„¤ì • ì—ì´ì „íŠ¸
setup_agent = Agent(
    name="Setup Agent",
    instructions="""
    Initialize new customer accounts.

    Tasks:
    1. Create default workspace
    2. Set up first project template
    3. Configure notification preferences
    4. Invite team members (if provided)
    5. Connect integrations (if requested)

    Use customer's industry to customize templates.
    """,
    tools=[
        create_workspace,
        create_project_from_template,
        send_team_invites,
        setup_integrations
    ]
)

# 3. êµìœ¡ ì—ì´ì „íŠ¸
training_agent = Agent(
    name="Training Agent",
    instructions="""
    Provide personalized training based on user role and goals.

    Training paths:
    - Project Manager: Focus on planning, timelines, reporting
    - Developer: Focus on task management, Git integration
    - Designer: Focus on file management, feedback tools

    Delivery methods:
    - Interactive in-app tutorial
    - Short video clips (2-3 min)
    - Quick reference cards
    - Practice tasks with feedback

    Track progress and adapt difficulty.
    """,
    tools=[
        show_interactive_tutorial,
        send_training_video,
        create_practice_task,
        track_completion
    ]
)

# 4. í”„ë¡œì•¡í‹°ë¸Œ ì§€ì› ì—ì´ì „íŠ¸
support_agent = Agent(
    name="Proactive Support",
    instructions="""
    Monitor new customers and provide proactive help.

    Triggers:
    - User stuck on same page > 2 minutes â†’ Offer help
    - Failed action > 3 times â†’ Show guide
    - No activity for 2 days â†’ Send encouragement email
    - First milestone reached â†’ Celebrate & suggest next step

    Tone: Friendly, non-intrusive, empowering
    """,
    tools=[
        detect_user_struggle,
        send_contextual_help,
        send_email,
        schedule_followup
    ]
)

# ì‹¤í–‰
async def onboard_customer(customer_data):
    result = await Runner.run(
        onboarding_orchestrator,
        f"Onboard new customer: {customer_data}"
    )
    return result

# ì‚¬ìš© ì˜ˆì œ
customer = {
    "name": "Alice Johnson",
    "email": "alice@startup.com",
    "company": "Tech Startup",
    "role": "Product Manager",
    "team_size": 15,
    "industry": "SaaS",
    "goals": ["Launch new feature", "Improve team collaboration"]
}

await onboard_customer(customer)
```

#### ê²°ê³¼

- âœ… ì˜¨ë³´ë”© ì‹œê°„: í‰ê·  4ì‹œê°„ â†’ 1.2ì‹œê°„ (70% ê°ì†Œ)
- âœ… í™œì„± ì‚¬ìš©ì ì „í™˜ìœ¨: 35% â†’ 68%
- âœ… ì²« ì£¼ ì œí’ˆ ë„ì…ë¥ : 52% â†’ 89%
- âœ… ì§€ì› í‹°ì¼“: ì˜¨ë³´ë”© ê´€ë ¨ í‹°ì¼“ 83% ê°ì†Œ

---

### ì¼€ì´ìŠ¤ 2: ë°ì´í„° íŒŒì´í”„ë¼ì¸ ìë™í™”

<strong>ê¸°ì—…</strong>: E-commerce í”Œë«í¼
<strong>ëª©í‘œ</strong>: ETL íŒŒì´í”„ë¼ì¸ ì¥ì•  ìë™ ë³µêµ¬

#### êµ¬í˜„ ì½”ë“œ

```python
from agents import Agent, Runner
import asyncio

# 1. ë°ì´í„° ëª¨ë‹ˆí„°ë§ ì—ì´ì „íŠ¸
monitor_agent = Agent(
    name="Pipeline Monitor",
    instructions="""
    Monitor data pipeline health 24/7.

    Check:
    - Data freshness (< 15 min lag)
    - Row count anomalies (Â±20% from expected)
    - Schema changes
    - Failed jobs

    On anomaly: Alert and delegate to Troubleshooter.
    """,
    tools=[
        check_pipeline_status,
        calculate_data_lag,
        detect_anomalies,
        send_alert
    ],
    handoffs=["Troubleshooter Agent"]
)

# 2. íŠ¸ëŸ¬ë¸”ìŠˆíŒ… ì—ì´ì „íŠ¸
troubleshooter_agent = Agent(
    name="Troubleshooter Agent",
    instructions="""
    Diagnose and fix pipeline issues.

    Diagnostic process:
    1. Check logs for error patterns
    2. Verify source data availability
    3. Test connections
    4. Check resource usage (CPU, memory)

    Auto-fix if possible:
    - Restart failed jobs
    - Clear stale locks
    - Retry with backoff

    Escalate if:
    - Schema incompatibility
    - Source system down
    - Data corruption
    """,
    tools=[
        read_logs,
        restart_job,
        clear_locks,
        test_connection,
        check_resources
    ],
    handoffs=["Engineer On-Call"]
)

# 3. ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ ë£¨í”„
async def monitor_pipeline():
    while True:
        result = await Runner.run(
            monitor_agent,
            "Check pipeline health"
        )

        if result.status == "anomaly_detected":
            # ìë™ íŠ¸ëŸ¬ë¸”ìŠˆíŒ… ì‹œì‘
            fix_result = await Runner.run(
                troubleshooter_agent,
                f"Fix issue: {result.anomaly_description}"
            )

            if fix_result.status == "fixed":
                print(f"âœ… ìë™ ë³µêµ¬ ì™„ë£Œ: {fix_result.action_taken}")
            else:
                print(f"âš ï¸ ì¸ê°„ ê°œì… í•„ìš”: {fix_result.escalation_reason}")

        await asyncio.sleep(60)  # 1ë¶„ë§ˆë‹¤ ì²´í¬

# ì‹¤í–‰
asyncio.run(monitor_pipeline())
```

#### ê²°ê³¼

- âœ… í‰ê·  ë³µêµ¬ ì‹œê°„ (MTTR): 45ë¶„ â†’ 8ë¶„ (82% ê°ì†Œ)
- âœ… ìë™ ë³µêµ¬ìœ¨: 78% (ì¸ê°„ ê°œì… ì—†ì´ í•´ê²°)
- âœ… ì—°ê°„ ë‹¤ìš´íƒ€ì„: 120ì‹œê°„ â†’ 22ì‹œê°„
- âœ… ì—”ì§€ë‹ˆì–´ ëŒ€ê¸° ì‹œê°„: ì£¼ 15ì‹œê°„ â†’ 3ì‹œê°„

---

### ì¼€ì´ìŠ¤ 3: DevOps ì›Œí¬í”Œë¡œìš° ìë™í™”

<strong>ê¸°ì—…</strong>: í•€í…Œí¬ ìŠ¤íƒ€íŠ¸ì—…
<strong>ëª©í‘œ</strong>: ë°°í¬ í”„ë¡œì„¸ìŠ¤ ì™„ì „ ìë™í™”, ìˆ˜ë™ ì‘ì—… ì œë¡œ

#### ì™„ì „ ìë™í™”ëœ ë°°í¬ íŒŒì´í”„ë¼ì¸

```python
from agents import Agent, Runner

# 1. PR ë¦¬ë·°ì–´
pr_reviewer = Agent(
    name="PR Reviewer",
    instructions="""
    Review pull requests for:
    - Code quality
    - Security vulnerabilities
    - Performance implications
    - Test coverage (>80%)
    - Breaking changes

    Auto-approve if all checks pass.
    Request changes if issues found.
    """,
    tools=[run_linter, run_security_scan, check_test_coverage],
    handoffs=["Human Reviewer"]  # ë³µì¡í•œ ê²½ìš°ë§Œ
)

# 2. í…ŒìŠ¤íŠ¸ ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´í„°
test_orchestrator = Agent(
    name="Test Orchestrator",
    instructions="""
    Run comprehensive test suite:
    1. Unit tests (parallel)
    2. Integration tests
    3. E2E tests (critical paths)
    4. Performance tests
    5. Security tests

    On failure: Auto-bisect to find breaking commit.
    """,
    tools=[
        run_unit_tests,
        run_integration_tests,
        run_e2e_tests,
        run_performance_tests,
        bisect_commits
    ]
)

# 3. ë°°í¬ ì—ì´ì „íŠ¸
deployer = Agent(
    name="Deployment Agent",
    instructions="""
    Progressive deployment strategy:
    1. Deploy to canary (1% traffic)
    2. Monitor for 10 minutes
    3. If healthy: 25% traffic
    4. If healthy: 50% traffic
    5. If healthy: 100% traffic

    Rollback if:
    - Error rate > 1%
    - Latency increase > 20%
    - Custom metrics degradation

    Post-deployment:
    - Update changelog
    - Notify team on Slack
    - Create Datadog dashboard
    """,
    tools=[
        deploy_canary,
        check_health_metrics,
        rollback,
        update_changelog,
        send_slack_notification
    ]
)

# 4. ì „ì²´ íŒŒì´í”„ë¼ì¸
async def automated_deploy(pr_number):
    # Phase 1: ì½”ë“œ ë¦¬ë·°
    review = await Runner.run(pr_reviewer, f"Review PR #{pr_number}")
    if not review.approved:
        return {"status": "blocked", "reason": review.feedback}

    # Phase 2: í…ŒìŠ¤íŠ¸
    tests = await Runner.run(test_orchestrator, f"Test PR #{pr_number}")
    if not tests.passed:
        return {"status": "failed", "failing_tests": tests.failures}

    # Phase 3: ë°°í¬
    deployment = await Runner.run(deployer, f"Deploy PR #{pr_number}")
    return deployment

# ì‚¬ìš©
result = await automated_deploy(pr_number=1234)
```

#### ê²°ê³¼

- âœ… ë°°í¬ ë¹ˆë„: ì£¼ 2íšŒ â†’ ì¼ 5íšŒ
- âœ… ë°°í¬ ì‹¤íŒ¨ìœ¨: 12% â†’ 0.8%
- âœ… ë¡¤ë°± ì‹œê°„: 20ë¶„ â†’ 2ë¶„ (ìë™)
- âœ… ì—”ì§€ë‹ˆì–´ ì‹œê°„ ì ˆê°: ì£¼ 40ì‹œê°„

---

## ì„±ëŠ¥ ìµœì í™” ê³ ê¸‰ ê¸°ë²•

### 1. ë³‘ë ¬ ì²˜ë¦¬ íŒ¨í„´

```python
import asyncio
from agents import Agent, Runner

# ì—¬ëŸ¬ ì—ì´ì „íŠ¸ë¥¼ ë³‘ë ¬ë¡œ ì‹¤í–‰
async def parallel_execution():
    agents = [research_agent, analysis_agent, writing_agent]
    tasks = [
        Runner.run(research_agent, "Research topic A"),
        Runner.run(analysis_agent, "Analyze data B"),
        Runner.run(writing_agent, "Write summary C")
    ]

    # ë³‘ë ¬ ì‹¤í–‰ (ë™ì‹œì— ëª¨ë‘ ì‹œì‘)
    results = await asyncio.gather(*tasks)
    return results

# ìˆœì°¨ ì‹¤í–‰: 9ì´ˆ (ê° 3ì´ˆ)
# ë³‘ë ¬ ì‹¤í–‰: 3ì´ˆ (67% ê°œì„ !)
```

### 2. ìŠ¤íŠ¸ë¦¬ë° ì‘ë‹µ

```python
from agents import Agent, Runner

agent = Agent(name="Writer", instructions="...")

# ìŠ¤íŠ¸ë¦¬ë° ëª¨ë“œ
async for chunk in Runner.run_stream(agent, "Write a long article"):
    print(chunk, end="", flush=True)
    # ì‚¬ìš©ìì—ê²Œ ì¦‰ì‹œ í‘œì‹œ (UX ê°œì„ )
```

### 3. ë°°ì¹˜ ì²˜ë¦¬

```python
# ì—¬ëŸ¬ ìš”ì²­ì„ ë°°ì¹˜ë¡œ ì²˜ë¦¬
async def batch_process(requests: list):
    # 10ê°œì”© ë¬¶ì–´ì„œ ì²˜ë¦¬ (API ìµœì í™”)
    batch_size = 10
    results = []

    for i in range(0, len(requests), batch_size):
        batch = requests[i:i+batch_size]
        batch_results = await Runner.run_batch(agent, batch)
        results.extend(batch_results)

    return results

# 1000ê°œ ìš”ì²­: ê°œë³„ ì²˜ë¦¬ 100ì´ˆ â†’ ë°°ì¹˜ ì²˜ë¦¬ 15ì´ˆ
```

---

## ë‹¤ìŒ ë‹¨ê³„

AgentKitì„ ë§ˆìŠ¤í„°í–ˆìŠµë‹ˆë‹¤! ì´ì œ ì—¬ëŸ¬ë¶„ë§Œì˜ í”„ë¡œë•ì…˜ ì‹œìŠ¤í…œì„ êµ¬ì¶•í•  ì¤€ë¹„ê°€ ë˜ì—ˆìŠµë‹ˆë‹¤.

### ì¶”ì²œ í•™ìŠµ ê²½ë¡œ

1. <strong>ì‘ê²Œ ì‹œì‘</strong>: 1-2ê°œ ì—ì´ì „íŠ¸ë¡œ ë‹¨ìˆœí•œ ì›Œí¬í”Œë¡œìš° êµ¬ì¶•
2. <strong>ì¸¡ì •</strong>: Evalsë¡œ ì„±ëŠ¥ ì¶”ì 
3. <strong>ë°˜ë³µ</strong>: A/B í…ŒìŠ¤íŠ¸ë¡œ ì§€ì†ì  ê°œì„ 
4. <strong>í™•ì¥</strong>: ë” ë§ì€ ì—ì´ì „íŠ¸ì™€ ë³µì¡í•œ íŒ¨í„´ ì¶”ê°€
5. <strong>ìµœì í™”</strong>: ë³‘ë ¬ ì²˜ë¦¬, ìºì‹±, ìŠ¤íŠ¸ë¦¬ë° ì ìš©

### ì»¤ë®¤ë‹ˆí‹° ë° ë¦¬ì†ŒìŠ¤

- <strong>OpenAI DevDay 2025 ì˜ìƒ</strong>: ì‹¤ì „ ë°ëª¨ í™•ì¸
- <strong>AgentKit GitHub</strong>: ì»¤ë®¤ë‹ˆí‹° ì˜ˆì œ ë° í…œí”Œë¦¿
- <strong>MCP Hub</strong>: ë‹¤ì–‘í•œ MCP ì„œë²„ íƒìƒ‰
- <strong>r/OpenAI</strong>: ë‹¤ë¥¸ ê°œë°œìë“¤ê³¼ ê²½í—˜ ê³µìœ 

---

<strong>ì‹œë¦¬ì¦ˆ ì™„ë£Œ!</strong> ğŸ‰

ì´ì œ AgentKitì˜ ëª¨ë“  ê²ƒì„ ì•Œê²Œ ë˜ì—ˆìŠµë‹ˆë‹¤. [1ë¶€](/ko/blog/ko/openai-agentkit-tutorial-part1)ì—ì„œ ê¸°ì´ˆë¥¼, 2ë¶€ì—ì„œ ì‹¤ì „ ë§ˆìŠ¤í„°ë¥¼ ë°°ì› ìŠµë‹ˆë‹¤.

ì§ˆë¬¸ì´ë‚˜ í”¼ë“œë°±ì´ ìˆë‹¤ë©´ ëŒ“ê¸€ë¡œ ë‚¨ê²¨ì£¼ì„¸ìš”. ì—¬ëŸ¬ë¶„ì˜ AgentKit í”„ë¡œì íŠ¸ë¥¼ ê¸°ëŒ€í•©ë‹ˆë‹¤!
