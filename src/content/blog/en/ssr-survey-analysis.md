---
title: Analyzing Blog Revisit Intent with SSR Methodology
description: >-
  Experimental results and statistical analysis of 225 evaluations using
  LLM-based Semantic Similarity Rating. Validated high reliability with ICC 0.83
  and visualizations.
pubDate: '2025-10-24'
heroImage: ../../../assets/blog/ssr-survey-analysis-hero.jpg
tags:
  - ssr
  - llm
  - research
  - analytics
  - openai
  - data-science
relatedPosts:
  - slug: ai-agent-persona-analysis
    score: 0.91
    reason:
      ko: 'ì„ í–‰ í•™ìŠµ ìë£Œë¡œ ìœ ìš©í•˜ë©°, AI/ML ê¸°ì´ˆë¥¼ ë‹¤ë£¹ë‹ˆë‹¤.'
      ja: äº‹å‰å­¦ç¿’è³‡æ–™ã¨ã—ã¦æœ‰ç”¨ã§ã‚ã‚Šã€AI/MLã®åŸºç¤ã‚’æ‰±ã„ã¾ã™ã€‚
      en: 'Useful as prerequisite knowledge, covering AI/ML fundamentals.'
      zh: ä½œä¸ºå…ˆä¿®çŸ¥è¯†å¾ˆæœ‰ç”¨ï¼Œæ¶µç›–AI/MLåŸºç¡€ã€‚
  - slug: llm-consumer-research-ssr
    score: 0.91
    reason:
      ko: AI/ML ë¶„ì•¼ì—ì„œ ìœ ì‚¬í•œ ì£¼ì œë¥¼ ë‹¤ë£¨ë©° ë¹„ìŠ·í•œ ë‚œì´ë„ì…ë‹ˆë‹¤.
      ja: AI/MLåˆ†é‡ã§é¡ä¼¼ã—ãŸãƒˆãƒ”ãƒƒã‚¯ã‚’æ‰±ã„ã€åŒç¨‹åº¦ã®é›£æ˜“åº¦ã§ã™ã€‚
      en: Covers similar topics in AI/ML with comparable difficulty.
      zh: åœ¨AI/MLé¢†åŸŸæ¶µç›–ç±»ä¼¼ä¸»é¢˜ï¼Œéš¾åº¦ç›¸å½“ã€‚
  - slug: ai-content-recommendation-system
    score: 0.89
    reason:
      ko: AI/ML ë¶„ì•¼ì—ì„œ ìœ ì‚¬í•œ ì£¼ì œë¥¼ ë‹¤ë£¨ë©° ë¹„ìŠ·í•œ ë‚œì´ë„ì…ë‹ˆë‹¤.
      ja: AI/MLåˆ†é‡ã§é¡ä¼¼ã—ãŸãƒˆãƒ”ãƒƒã‚¯ã‚’æ‰±ã„ã€åŒç¨‹åº¦ã®é›£æ˜“åº¦ã§ã™ã€‚
      en: Covers similar topics in AI/ML with comparable difficulty.
      zh: åœ¨AI/MLé¢†åŸŸæ¶µç›–ç±»ä¼¼ä¸»é¢˜ï¼Œéš¾åº¦ç›¸å½“ã€‚
  - slug: openai-agentkit-tutorial-part2
    score: 0.87
    reason:
      ko: AI/ML ë¶„ì•¼ì—ì„œ ìœ ì‚¬í•œ ì£¼ì œë¥¼ ë‹¤ë£¨ë©° ë¹„ìŠ·í•œ ë‚œì´ë„ì…ë‹ˆë‹¤.
      ja: AI/MLåˆ†é‡ã§é¡ä¼¼ã—ãŸãƒˆãƒ”ãƒƒã‚¯ã‚’æ‰±ã„ã€åŒç¨‹åº¦ã®é›£æ˜“åº¦ã§ã™ã€‚
      en: Covers similar topics in AI/ML with comparable difficulty.
      zh: åœ¨AI/MLé¢†åŸŸæ¶µç›–ç±»ä¼¼ä¸»é¢˜ï¼Œéš¾åº¦ç›¸å½“ã€‚
  - slug: specification-driven-development
    score: 0.86
    reason:
      ko: AI/ML ë¶„ì•¼ì—ì„œ ìœ ì‚¬í•œ ì£¼ì œë¥¼ ë‹¤ë£¨ë©° ë¹„ìŠ·í•œ ë‚œì´ë„ì…ë‹ˆë‹¤.
      ja: AI/MLåˆ†é‡ã§é¡ä¼¼ã—ãŸãƒˆãƒ”ãƒƒã‚¯ã‚’æ‰±ã„ã€åŒç¨‹åº¦ã®é›£æ˜“åº¦ã§ã™ã€‚
      en: Covers similar topics in AI/ML with comparable difficulty.
      zh: åœ¨AI/MLé¢†åŸŸæ¶µç›–ç±»ä¼¼ä¸»é¢˜ï¼Œéš¾åº¦ç›¸å½“ã€‚
---

## Overview

Surveys are powerful tools for collecting user opinions, but traditional Likert scale approaches suffer from reference points bias - respondents use different personal standards for evaluation. What one person considers "neutral" might be "good" to another.

To address this problem, we conducted an experiment analyzing blog revisit intent using the <strong>SSR (Semantic Similarity Rating)</strong> methodology. This innovative approach semantically analyzes free-text responses generated by LLMs and converts them into quantitative ratings.

<strong>Core Question</strong>: How much revisit intent do the blog's 5 category contents evoke across 15 diverse personas?

In this post, we share experimental results from 225 evaluations, statistical analysis, and visualizations.

## What is SSR Methodology?

SSR is a methodology proposed in the paper ["LLMs Reproduce Human Purchase Intent via Semantic Similarity Elicitation of Likert Ratings"](https://arxiv.org/abs/2510.08338) published on arXiv in October 2024.

### Problems with Traditional LLM Surveys

Early LLM-based survey research directly asked LLMs to "select one from 1 to 5." However, this approach had serious problems:

<strong>Problem 1: Unrealistic Distribution</strong>
- Actual humans: Near-normal distribution (concentrated on 2, 3, 4)
- LLM direct evaluation: Extreme distribution (excessive concentration on 1 or 5)

<strong>Problem 2: Lack of Consistency</strong>
- Responses vary significantly even when repeating the same question
- Test-Retest reliability < 0.60

<strong>Problem 3: Loss of Context</strong>
- Cannot understand "why" they evaluated that way
- Absence of qualitative insights

### SSR's Innovative Solution

SSR is a clever approach that leverages LLM's strength in <strong>natural language generation</strong> while meeting the need for structured survey data.

```mermaid
graph TB
    subgraph Traditional["Traditional LLM Survey"]
        Q1[Question: Revisit intent?] --> A1["LLM direct response: 4<br/>(Unrealistic distribution)"]
        A1 --> R1[Rating 4.0]
    end

    subgraph SSR["SSR Methodology"]
        Q2[Question: Describe your revisit intent] --> A2["Free-text generation<br/>(Rich context)"]
        A2 --> E[Text embedding]
        E --> S["Similarity with anchors<br/>(Cosine Similarity)"]
        S --> P[Softmax â†’ Probability distribution]
        P --> R2[Expected rating 3.078]
    end
```

### 5-Step Algorithm

<strong>Step 1: Free-Text Response Generation</strong>
```python
prompt = """You are {persona_name}, a {occupation}.
Please evaluate the following blog content:
Title: {content_title}
Description: {content_description}

Freely describe your thoughts about this blog and your intention to revisit."""

response = await openai_client.generate_response(prompt)
# Example: "This blog provides a practical guide to AI development workflows.
#           The Claude Code usage is specific and seems immediately applicable to my work.
#           I would like to visit again and read other articles."
```

<strong>Step 2: Response Embedding</strong>
```python
response_embedding = await openai_client.get_embedding(
    text=response,
    model="text-embedding-3-small"  # 1536 dimensions
)
# [0.023, -0.145, 0.089, ...] (1536-dimensional vector)
```

<strong>Step 3: Calculate Cosine Similarity with Anchors</strong>
```python
ANCHORS = {
    1: "This blog does not meet my expectations at all, and I will not revisit.",
    2: "This blog has some value, but I probably won't revisit.",
    3: "This blog is okay, but I'm not sure if I'll revisit.",
    4: "This blog provides useful information, so I'm likely to revisit.",
    5: "This blog is excellent, and I will revisit regularly."
}

# Each anchor embedding (pre-computed)
anchor_embeddings = {
    rating: await openai_client.get_embedding(text)
    for rating, text in ANCHORS.items()
}

# Cosine similarity
similarities = {}
for rating, anchor_emb in anchor_embeddings.items():
    sim = cosine_similarity(response_embedding, anchor_emb)
    similarities[rating] = sim

# Example: {1: 0.12, 2: 0.25, 3: 0.45, 4: 0.78, 5: 0.62}
```

<strong>Step 4: Generate Probability Distribution with Softmax</strong>
```python
def softmax(similarities, temperature=1.0):
    """Convert cosine similarities to probability distribution"""
    values = np.array(list(similarities.values()))
    exp_values = np.exp(values / temperature)
    return exp_values / exp_values.sum()

probabilities = softmax(similarities)
# [0.05, 0.10, 0.20, 0.45, 0.20]  # Probability for each rating
```

<strong>Step 5: Calculate Expected Value</strong>
```python
ratings = [1, 2, 3, 4, 5]
expected_rating = sum(r * p for r, p in zip(ratings, probabilities))
# 3.65 = 1Ã—0.05 + 2Ã—0.10 + 3Ã—0.20 + 4Ã—0.45 + 5Ã—0.20
```

### Advantages of SSR

<strong>1. Semantic Consistency</strong>
- Eliminates differences in respondents' subjective scales
- All evaluations performed in the same embedding space

<strong>2. Rich Context Preservation</strong>
- Provides quantitative rating + qualitative explanation simultaneously
- Understand "why" they evaluated that way

<strong>3. High Reliability</strong>
- Test-Retest reliability: Achieves 90% of human level
- KS similarity > 0.85

<strong>4. Cost Efficiency</strong>
- About $0.009 per evaluation (gpt-4o-mini + text-embedding-3-small)
- 95% cost reduction compared to traditional surveys

## Experimental Design

### Persona Composition (15 people)

We generated personas from diverse countries and occupations:

| Name | Country | Occupation |
|------|---------|------------|
| Alex Johnson | USA | Senior Software Engineer |
| ê¹€ì„œì—° | South Korea | AI Researcher |
| ç”°ä¸­å¥å¤ª (Tanaka Kenta) | Japan | Data Engineer |
| Hans MÃ¼ller | Germany | ML Engineer |
| Priya Sharma | India | Data Analyst |
| Carlos Santos | Brazil | Backend Developer |
| Emily Roberts | UK | Product Manager |
| Sophie Tremblay | Canada | DevOps Engineer |
| Wei Zhang | Singapore | AI Product Developer |
| Pierre Dubois | France | Data Scientist |
| Olivia Chen | Australia | UX Researcher |
| Dr. Michael Lee | USA | AI Researcher |
| Lars van der Berg | Netherlands | Software Architect |
| ë°•ì§€í›ˆ | South Korea | Full-Stack Developer |
| Li Wei | China | AI Student |

Each persona includes the following information:
- Demographics: Age, country, occupation
- Interests: AI/ML, data engineering, web development, etc.
- Search queries: Actual search terms based on Google Search Console
- Tech stack: Python, JavaScript, React, Docker, etc.

### Evaluated Contents (5 items)

1. <strong>Claude Code Best Practices</strong> - AI-Powered Development Workflow
2. <strong>Data Mesh vs Data Warehouse</strong> - Architectural Decision Framework
3. <strong>Google Analytics MCP</strong> - Automating Google Analytics with Model Context Protocol
4. <strong>Screenshot to Code</strong> - AI-Powered Screenshot to Code Tools and Techniques
5. <strong>GraphRAG and Multi-Agent Systems</strong> - Advanced AI Architecture

### Experimental Setup

- <strong>Total evaluations</strong>: 225 (15 personas Ã— 5 contents Ã— 3 repetitions)
- <strong>Reason for repetition</strong>: Test-Retest reliability verification
- <strong>LLM model</strong>: gpt-4o-mini (cost-efficient)
- <strong>Embedding model</strong>: text-embedding-3-small (1536 dimensions)
- <strong>Temperature</strong>: 0.7 (balanced consistency and diversity)
- <strong>Execution time</strong>: Approximately 8 minutes 24 seconds
- <strong>Total cost</strong>: Approximately $2.00

## Implementation Code

The entire system was implemented in Python, with the following main modules:

### OpenAI Client

```python
from openai import AsyncOpenAI

class OpenAIClient:
    def __init__(self, api_key: str):
        self.client = AsyncOpenAI(api_key=api_key)
        self.llm_model = "gpt-4o-mini"
        self.embedding_model = "text-embedding-3-small"

    async def generate_response(
        self,
        prompt: str,
        temperature: float = 0.7
    ) -> str:
        """Generate LLM free-text response"""
        response = await self.client.chat.completions.create(
            model=self.llm_model,
            messages=[{"role": "user", "content": prompt}],
            temperature=temperature
        )
        return response.choices[0].message.content

    async def get_embedding(self, text: str) -> List[float]:
        """Generate text embedding"""
        response = await self.client.embeddings.create(
            model=self.embedding_model,
            input=text
        )
        return response.data[0].embedding
```

### SSR Rater

```python
import numpy as np
from typing import Dict, List

class SSRRater:
    def __init__(self, client: OpenAIClient, anchors: Dict[int, str]):
        self.client = client
        self.anchors = anchors
        self.anchor_embeddings = {}

    async def initialize_anchors(self):
        """Pre-compute anchor embeddings (executed only once)"""
        for rating, text in self.anchors.items():
            self.anchor_embeddings[rating] = await self.client.get_embedding(text)

    def cosine_similarity(
        self,
        vec1: List[float],
        vec2: List[float]
    ) -> float:
        """Calculate cosine similarity"""
        vec1 = np.array(vec1)
        vec2 = np.array(vec2)
        return np.dot(vec1, vec2) / (np.linalg.norm(vec1) * np.linalg.norm(vec2))

    def softmax(
        self,
        similarities: Dict[int, float],
        temperature: float = 1.0
    ) -> List[float]:
        """Generate softmax probability distribution"""
        values = np.array(list(similarities.values()))
        exp_values = np.exp(values / temperature)
        return exp_values / exp_values.sum()

    async def evaluate(
        self,
        persona: Dict,
        content: Dict,
        prompt_template: str
    ) -> Dict:
        """Execute SSR evaluation"""
        # 1. Generate free-text response
        prompt = prompt_template.format(**persona, **content)
        response = await self.client.generate_response(prompt)

        # 2. Embed response
        response_embedding = await self.client.get_embedding(response)

        # 3. Calculate similarity with anchors
        similarities = {}
        for rating, anchor_emb in self.anchor_embeddings.items():
            sim = self.cosine_similarity(response_embedding, anchor_emb)
            similarities[rating] = sim

        # 4. Generate probability distribution
        probabilities = self.softmax(similarities)

        # 5. Calculate expected value
        ratings = list(similarities.keys())
        expected_rating = sum(r * p for r, p in zip(ratings, probabilities))

        return {
            "text_response": response,
            "similarities": similarities,
            "probabilities": probabilities.tolist(),
            "expected_rating": expected_rating,
            "most_likely_rating": ratings[np.argmax(probabilities)]
        }
```

### Survey Runner

```python
import asyncio
from tqdm.asyncio import tqdm

class SurveyRunner:
    def __init__(self, rater: SSRRater):
        self.rater = rater

    async def run_survey(
        self,
        personas: List[Dict],
        contents: List[Dict],
        prompt_template: str,
        repetitions: int = 3,
        max_concurrent: int = 10
    ) -> List[Dict]:
        """Execute full survey"""
        # Create evaluation tasks
        evaluations = []
        for persona in personas:
            for content in contents:
                for rep in range(repetitions):
                    evaluations.append({
                        "persona": persona,
                        "content": content,
                        "repetition": rep + 1
                    })

        # Parallel execution (with progress bar)
        semaphore = asyncio.Semaphore(max_concurrent)

        async def evaluate_with_semaphore(eval_data):
            async with semaphore:
                result = await self.rater.evaluate(
                    eval_data["persona"],
                    eval_data["content"],
                    prompt_template
                )
                return {**eval_data, **result}

        results = []
        for coro in tqdm.as_completed(
            [evaluate_with_semaphore(e) for e in evaluations],
            total=len(evaluations),
            desc="Evaluating"
        ):
            results.append(await coro)

        return results
```

## Experimental Results

### Overall Statistics

| Metric | Value |
|--------|-------|
| <strong>Average Expected Rating</strong> | 3.078 / 5.0 |
| <strong>Standard Deviation</strong> | 0.016 |
| <strong>Minimum</strong> | 3.010 |
| <strong>Maximum</strong> | 3.106 |
| <strong>Median</strong> | 3.080 |

### Rating Distribution

| Rating | Frequency | Percentage |
|--------|-----------|------------|
| <strong>1 point</strong> | 0 | 0.0% |
| <strong>2 points</strong> | 0 | 0.0% |
| <strong>3 points</strong> | 0 | 0.0% |
| <strong>4 points</strong> | 219 | 97.3% |
| <strong>5 points</strong> | 6 | 2.7% |

<strong>Interpretation</strong>:
- Almost all evaluations (97.3%) resulted in <strong>"High revisit intent" (4 points)</strong>
- Only a small minority (2.7%) showed <strong>"Very high revisit intent" (5 points)</strong>
- <strong>Not a single evaluation below 3 points</strong> â†’ All content is positive for inducing revisits
- Average 3.078 is the expected value; the most likely rating is actually 4 points

### Content Ranking

| Rank | Content | Average Rating | Std Dev |
|------|---------|----------------|---------|
| 1 | <strong>Claude Code Best Practices</strong> | 3.086 | 0.009 |
| 2 | <strong>GraphRAG and Multi-Agent Systems</strong> | 3.082 | 0.016 |
| 3 | <strong>Screenshot to Code</strong> | 3.082 | 0.017 |
| 4 | <strong>Data Mesh vs Data Warehouse</strong> | 3.070 | 0.015 |
| 5 | <strong>Google Analytics MCP</strong> | 3.070 | 0.013 |

<strong>Insights</strong>:
- <strong>1st place Claude Code</strong>: Highest rating + lowest standard deviation (0.009)
  - Very high interest in AI development workflows, consistently positive across all personas
- <strong>2-3rd place GraphRAG, Screenshot to Code</strong>: High interest in advanced AI technology and practical tools
- <strong>4-5th place Data Mesh, GA MCP</strong>: Data architecture and analytics tool automation
- Difference between 1st and 5th is only 0.016 â†’ <strong>All content maintains uniformly high quality</strong>

### Persona Ranking

<strong>Top 5</strong>:

| Name | Country | Occupation | Average Rating |
|------|---------|------------|----------------|
| ë°•ì§€í›ˆ | South Korea | Full-Stack Developer | 3.089 |
| Alex Johnson | USA | Senior Software Engineer | 3.088 |
| Emily Roberts | UK | Product Manager | 3.087 |
| Pierre Dubois | France | Data Scientist | 3.086 |
| Wei Zhang | Singapore | AI Product Developer | 3.083 |

<strong>Bottom 5</strong>:

| Name | Country | Occupation | Average Rating |
|------|---------|------------|----------------|
| Dr. Michael Lee | USA | AI Researcher | 3.059 |
| ç”°ä¸­å¥å¤ª | Japan | Data Engineer | 3.065 |
| Hans MÃ¼ller | Germany | ML Engineer | 3.068 |
| Carlos Santos | Brazil | Backend Developer | 3.069 |
| Li Wei | China | AI Student | 3.070 |

<strong>Insights</strong>:
- Developers from South Korea, USA, and Europe show high revisit intent
- AI researcher (Dr. Michael Lee) is relatively lower but still positive at 3.059
- Low standard deviation (0.009-0.025) â†’ Consistent responses across repeated measurements

### Visualizations

#### 1. Rating Distribution Analysis

![Distribution Analysis](../../../assets/blog/distribution_analysis.png)

<strong>Top Left</strong>: Most Likely Ratings - 97.3% concentrated on 4 points
<strong>Top Right</strong>: Expected Ratings - Average 3.078, standard deviation 0.016
<strong>Bottom Left</strong>: Probability distribution by evaluation (first 20)
<strong>Bottom Right</strong>: Results with Softmax Temperature 1.0 applied

#### 2. Persona Ã— Content Heatmap

![Heatmap](../../../assets/blog/heatmap_expected_rating.png)

- <strong>Bright colors</strong>: High revisit intent
- <strong>Dark colors</strong>: Relatively lower revisit intent
- All cells are relatively bright â†’ Overall high ratings

<strong>Findings</strong>:
- <strong>ë°•ì§€í›ˆ (Full-Stack Developer)</strong>: High ratings for all content
- <strong>Claude Code Best Practices</strong>: High ratings from almost all personas
- <strong>Japanese Data Engineer (ç”°ä¸­)</strong>: Relatively lower pattern (cultural/linguistic differences?)

#### 3. Persona-wise Box Plot

![Box Plot](../../../assets/blog/boxplot_analysis.png)

<strong>Top</strong>: Rating distribution by persona - Most concentrated in 3.05-3.10 range
<strong>Bottom</strong>: Rating distribution by content - Claude Code has highest median

#### 4. Correlation Matrix

![Correlation Matrix](../../../assets/blog/correlation_matrix.png)

Pearson correlation coefficients between 3 repetitions:
- <strong>Rep1 vs Rep2</strong>: 0.73
- <strong>Rep1 vs Rep3</strong>: 0.53
- <strong>Rep2 vs Rep3</strong>: 0.62

## Statistical Reliability Analysis

### Test-Retest Reliability

We verified consistency by measuring each persona Ã— content combination 3 times.

#### ICC (Intraclass Correlation Coefficient)

```python
from scipy import stats

# Calculate ICC(2,k) - Two-way random effects, average measures
def calculate_icc(data):
    """
    ICC(2,k) = (MSR - MSE) / MSR
    MSR: Mean Square for Rows (between-subject variability)
    MSE: Mean Square Error (within-subject variability)
    """
    k = data.shape[1]  # number of raters (repetitions)
    n = data.shape[0]  # number of subjects

    # Sum of Squares
    subject_means = data.mean(axis=1)
    grand_mean = data.values.mean()

    SS_between = k * np.sum((subject_means - grand_mean) ** 2)
    SS_within = np.sum((data.values - subject_means.values[:, np.newaxis]) ** 2)

    # Mean Squares
    MS_between = SS_between / (n - 1)
    MS_within = SS_within / (n * (k - 1))

    # ICC
    icc = (MS_between - MS_within) / MS_between
    return icc

icc_score = calculate_icc(pivot_data)  # 0.8330
```

<strong>Result</strong>: ICC = <strong>0.8330</strong>

<strong>Interpretation</strong>:
- <strong>0.75 or above</strong>: Good reliability
- <strong>0.85 or above</strong>: Excellent reliability
- <strong>0.8330</strong>: Demonstrates the stability of SSR methodology
- Paper's claim (Test-Retest reliability â‰¥ 0.85 at 90% level) <strong>verified</strong>

#### Pearson Correlation Coefficients

| Comparison | Correlation (r) | Interpretation |
|------------|-----------------|----------------|
| Repetition 1 vs 2 | 0.7301 | High correlation |
| Repetition 1 vs 3 | 0.5298 | Moderate correlation |
| Repetition 2 vs 3 | 0.6246 | Moderate-high correlation |

<strong>Overall Assessment</strong>:
- âœ… <strong>Very high reliability</strong>: Standard deviation < 0.01 (8 people)
- âœ… <strong>High reliability</strong>: Standard deviation 0.01-0.02 (6 people)
- âš ï¸ <strong>Moderate reliability</strong>: Standard deviation 0.02-0.03 (1 person)

### Meaning of Reliability

<strong>SSR Methodology Verification</strong>:
- Standard deviation < 0.02 for most personas
- Consistent results across repeated measurements â†’ <strong>Demonstrates SSR method stability</strong>
- Similar consistency to actual human response patterns

## Cost Analysis

### Actual Cost

| Item | Quantity | Unit Price | Cost |
|------|----------|------------|------|
| <strong>Anchor Embedding</strong> | 5 times | $0.00001/token Ã— ~20 tokens | $0.0010 |
| <strong>LLM Response Generation</strong> | 225 times | $0.15/1M tokens Ã— ~100 tokens | $3.38 |
| <strong>Response Embedding</strong> | 225 times | $0.00001/token Ã— ~50 tokens | $0.11 |
| <strong>Total Cost</strong> | - | - | <strong>~$3.50</strong> |

<strong>Actual Measurement</strong>:
- Expected cost: $2-3
- Actual cost: About $3.50 (more tokens than expected)
- Cost per evaluation: <strong>$0.016</strong>

### Cost Efficiency

<strong>Comparison with Traditional Surveys</strong>:

| Method | Cost per Respondent | Cost for 225 Responses | Time Required |
|--------|---------------------|------------------------|---------------|
| Traditional Survey | $1-5 | $225-1,125 | 1-2 weeks |
| SSR | $0.016 | $3.50 | 8 minutes |

<strong>Savings</strong>:
- <strong>Cost</strong>: 95-99% reduction
- <strong>Time</strong>: 99% reduction
- <strong>Scale</strong>: No constraints (thousands to tens of thousands of evaluations possible)

### Additional Benefits

<strong>Qualitative Benefits</strong>:
1. <strong>Rich Context</strong>: Detailed text responses for each evaluation
2. <strong>Immediate Execution</strong>: Instant results with just API calls
3. <strong>Easy Repetition</strong>: Simple re-evaluation when content changes
4. <strong>A/B Testing</strong>: Simultaneous testing of multiple versions

## Key Findings

### 1. Overall High Revisit Intent

- <strong>Average 3.078/5.0</strong> â†’ Most at "High revisit intent" (4 points) level
- 97.3% at 4 points, only 2.7% at 5 â†’ Content quality is excellent but not "perfect"
- <strong>Room for improvement</strong>: Need to strengthen content for 4â†’5 point conversion

### 2. Small Differences Between Contents

- Difference between 1st (Claude Code) and 5th (GA MCP) is only 0.016
- <strong>All content maintains uniformly high quality</strong>
- Not biased toward specific categories

### 3. Developer-Centric Content Ranks Higher

- Claude Code, GraphRAG, Screenshot to Code are top 3
- <strong>Strategy</strong>: Strengthen AI development tools and workflow content
- High demand for practical guides

### 4. Minimal Regional/Occupational Differences

- South Korea (ë°•ì§€í›ˆ 3.089) vs Japan (ç”°ä¸­ 3.065) difference 0.024
- US Senior Dev (Alex 3.088) vs AI Researcher (Michael 3.059) difference 0.029
- <strong>Universal Interest</strong>: AI development trends transcend country/occupation

### 5. High Methodology Reliability

- Average standard deviation 0.014 â†’ Excellent consistency in repeated measurements
- ICC 0.833 â†’ Demonstrates SSR methodology stability
- Similar to actual human response patterns

## Blog Operation Utilization

### 1. Content Strategy

<strong>Priority Content</strong>:
- <strong>Expand Claude Code Series</strong>: Highest interest, so create sequels
  - Part 2: Advanced patterns
  - Part 3: Production use cases
- <strong>Focus on AI Development Workflow</strong>: Strengthen developer-centric content
- <strong>Deepen GraphRAG/Multi-Agent</strong>: Confirmed demand for advanced topics

<strong>4â†’5 Point Conversion Strategy</strong>:
- Add hands-on examples (Hands-on Tutorials)
- Include case studies (Real-world Examples)
- Provide code repositories (GitHub Repos)
- Supplement with video tutorials

### 2. Target Audience Analysis

<strong>Core Readership</strong>:
- Developers from USA, South Korea, Europe
- AI/ML Engineers, Full-Stack Developers
- Tech Workers aged 25-40

<strong>Expandable Readership</strong>:
- Developers from Japan, Brazil (3.06-3.07 level)
- Data Analysts, Product Managers (data-driven decision making)

<strong>Multilingual Content Priority</strong>:
1. English (Essential - global audience)
2. Korean (Core - domestic audience)
3. Japanese (Expansion - potential audience)

### 3. Additional Research Topics

<strong>Quantitative Analysis</strong>:
- <strong>4â†’5 Point Conversion Factors</strong> analysis: What elements induce "very high" revisit intent?
- <strong>Persona-specific Preferred Content</strong>: Build occupation-specific customized recommendation system
- <strong>Time Series Analysis</strong>: Changes in revisit intent over time after content publication

<strong>Qualitative Analysis</strong>:
- <strong>Text Response Analysis</strong>: Extract key keywords from free responses
- <strong>Sentiment Analysis</strong>: Ratio of positive/negative sentiment
- <strong>Topic Modeling</strong>: Discover hidden topics with LDA/BERTopic

## Limitations and Improvement Directions

### Current Limitations

<strong>1. LLM Bias</strong>
- Bias exists toward Western, English-speaking, developed countries
- May not adequately reflect consumption patterns of certain cultural regions

<strong>2. Limitations of Synthetic Personas</strong>
- Not completely identical to actual human responses
- Difficulty capturing subtle cultural nuances

<strong>3. Impact of Anchor Sentences</strong>
- Results may vary depending on anchor sentence selection
- Need domain-specific optimization

### Improvement Directions

<strong>1. Validation with Real Data</strong>
- Validate SSR results with small-scale actual surveys
- Measure accuracy through A/B testing

<strong>2. Use Multiple Models</strong>
- Reduce bias by ensembling results from multiple LLMs
- Compare GPT-4, Claude, Gemini

<strong>3. Prompt Engineering</strong>
- Improve prompts considering cultural context
- Refine persona definitions

<strong>4. Continuous Monitoring</strong>
- Regularly re-measure reliability
- Immediately evaluate upon new content publication

## Conclusion

### Summary of Achievements

- âœ… <strong>100% success for 225 evaluations</strong> (8 minutes 24 seconds, about $3.50 cost)
- âœ… <strong>Average revisit intent 3.078/5.0</strong> â†’ All content is positive
- âœ… <strong>SSR methodology validated</strong> â†’ High Test-Retest reliability (ICC 0.833)
- âœ… <strong>Actionable insights derived</strong> â†’ Content strategy formulation possible

### Blog Operation Recommendations

1. <strong>Expand Claude Code Series</strong>: Highest interest
2. <strong>Strengthen AI Development Workflow Content</strong>: GraphRAG, Multi-Agent, Screenshot-to-Code
3. <strong>Multilingual Support</strong>: Prioritize English, Korean, Japanese
4. <strong>4â†’5 Point Conversion Strategy</strong>: Deepen content quality (add hands-on examples, case studies)

### Potential of SSR Methodology

SSR goes beyond being just a survey tool to become an <strong>innovative tool for content strategy formulation</strong>:

<strong>Applicable Areas</strong>:
- Blog content revisit intent (this study)
- Product purchase intent (original SSR purpose)
- Service subscription intent
- Ad click intent
- Brand preference

<strong>Core Contributions</strong>:
- âœ“ Cost-efficient large-scale evaluation ($0.016 per evaluation)
- âœ“ Rapid iterative experiments (results in minutes)
- âœ“ Combination of quantitative evaluation + qualitative insights
- âœ“ High reliability (ICC 0.833)

The consumer research and content strategy fields are facing a new turning point in the AI era. Technologies like SSR will become powerful tools for blog operators and marketers to create better content and understand their audience more deeply.

## References

### Academic Papers
- [arXiv 2510.08338] LLMs Reproduce Human Purchase Intent via Semantic Similarity Elicitation of Likert Ratings

### Implementation References
- [PyMC Labs GitHub](https://github.com/pymc-labs/semantic-similarity-rating) - SSR algorithm open-source implementation
- [OpenAI Embeddings Guide](https://platform.openai.com/docs/guides/embeddings)

### Blog Posts
- [New Ways AI Predicts Consumer Behavior: Semantic Similarity Rating](/blog/en/llm-consumer-research-ssr) - Introduction to SSR methodology

### Related Research
- [Research on LLM Bias in Survey Research](https://www.nature.com/articles/s41599-024-03609-x)
- [VentureBeat: Digital Twin Consumers](https://venturebeat.com/ai/this-new-ai-technique-creates-digital-twin-consumers-and-it-could-kill-the)

---

<strong>ğŸ“Š Code & Data</strong>: The complete code and data used in this analysis are available in the [GitHub repository](https://github.com/kimjangwook/ssr-repeater).
