# 복구 프로토콜 (Recovery Protocol)

## 개요

Deep Agents에서 실패는 불가피합니다. 이 문서는 실패를 감지, 분류, 복구하는 표준 프로토콜을 정의합니다. 맹목적인 재시도 대신 전략적 재계획을 통해 복잡한 작업의 성공률을 높입니다.

---

## 실패 유형 분류

### 1. Transient Failure (일시적 실패)
- **원인**: 네트워크 오류, API rate limit, 일시적 서비스 중단
- **특징**: 재시도 시 해결 가능
- **대응**: 지수 백오프 재시도

### 2. Validation Failure (검증 실패)
- **원인**: 출력 품질 미달, 형식 오류, 요구사항 불충족
- **특징**: 수정 후 재제출 필요
- **대응**: 피드백과 함께 수정 요청

### 3. Dependency Failure (의존성 실패)
- **원인**: 선행 단계 실패, 필요 입력 부재
- **특징**: 의존 단계 해결 후 진행 가능
- **대응**: 의존 단계 복구 후 재실행

### 4. Resource Failure (리소스 실패)
- **원인**: 파일 없음, 권한 부족, 메모리 부족
- **특징**: 리소스 확보 후 진행 가능
- **대응**: 리소스 확보 또는 대안 경로

### 5. Structural Failure (구조적 실패)
- **원인**: 접근 방식 자체가 불가능
- **특징**: 재시도로 해결 불가
- **대응**: 재계획 필요

### 6. Critical Failure (치명적 실패)
- **원인**: 복구 불가능한 오류, 보안 문제
- **특징**: 작업 중단 필요
- **대응**: 사용자 에스컬레이션

---

## 복구 결정 트리

```
실패 감지
    │
    ▼
┌─────────────┐
│ 일시적 오류? │ → Yes → 재시도 (최대 3회, 지수 백오프)
└─────────────┘           │
    │ No                  ▼
    ▼                 성공? → Yes → 계속 진행
┌─────────────┐           │
│ 검증 실패?   │ → Yes → 수정 요청 (피드백 포함)
└─────────────┘           │
    │ No                  ▼
    ▼                 성공? → Yes → 계속 진행
┌─────────────┐           │
│ 의존성 실패? │ → Yes → 의존 단계 복구
└─────────────┘           │
    │ No                  ▼
    ▼                 성공? → Yes → 계속 진행
┌─────────────┐           │
│ 리소스 실패? │ → Yes → 리소스 확보 또는 대안
└─────────────┘           │
    │ No                  ▼
    ▼                 성공? → Yes → 계속 진행
┌─────────────┐           │
│ 대안 가능?   │ → Yes → 대안 경로 실행
└─────────────┘           │
    │ No                  ▼
    ▼                 성공? → Yes → 계속 진행
┌─────────────┐           │
│ 재계획 가능? │ → Yes → 재계획 수행
└─────────────┘
    │ No
    ▼
사용자 에스컬레이션
```

---

## 복구 전략

### 1. 재시도 (Retry)

**적용 상황**: 일시적 실패

**구현**:
```python
MAX_RETRIES = 3
BASE_DELAY = 2  # seconds

for attempt in range(MAX_RETRIES):
    try:
        result = execute_step(step)
        break
    except TransientError as e:
        if attempt < MAX_RETRIES - 1:
            delay = BASE_DELAY * (2 ** attempt)  # 지수 백오프
            sleep(delay)
        else:
            escalate(e)
```

### 2. 수정 요청 (Revision Request)

**적용 상황**: 검증 실패

**구현**:
```markdown
## 수정 요청

### 에이전트
[담당 에이전트]

### 원본 출력
[원본 내용 요약]

### 검증 실패 사유
- [사유 1]
- [사유 2]

### 수정 요구사항
- [요구사항 1]
- [요구사항 2]

### 기한
[시간 제한 있을 경우]
```

### 3. 대안 경로 (Alternative Path)

**적용 상황**: 특정 경로 실패, 대안 존재

**예시**:
- API A 실패 → API B 사용
- 도구 X 실패 → 도구 Y 사용
- 에이전트 A 실패 → 에이전트 B 위임

### 4. 재계획 (Replan)

**적용 상황**: 구조적 실패, 3회 재시도 실패

**절차**:
1. 현재 상태 저장 (완료된 단계, 중간 결과)
2. 실패 원인 분석
3. 새 계획 수립 (대안 접근 방식)
4. 새 계획 검증
5. 새 계획으로 실행 재개

### 5. 사용자 에스컬레이션

**적용 상황**: 자동 복구 불가

**내용**:
```markdown
## 작업 중단 보고

### 작업
[작업명]

### 실패 단계
[단계 N]

### 실패 원인
[상세 설명]

### 시도한 복구
- [시도 1]: [결과]
- [시도 2]: [결과]

### 필요한 조치
- [조치 1]
- [조치 2]

### 저장된 상태
- 완료된 단계: [N개]
- 중간 결과: [위치]
```

---

## 복구 시 상태 관리

### 실패 감지 시

```json
{
  "current_task": {
    "plan": {
      "steps": [
        {
          "id": 1,
          "status": "failed",
          "error": {
            "type": "transient",
            "message": "API rate limit exceeded",
            "timestamp": "2025-11-18T10:30:00Z",
            "retries": 2
          }
        }
      ]
    },
    "issues": [
      {
        "step_id": 1,
        "type": "transient",
        "message": "API rate limit exceeded",
        "resolution": "retry",
        "resolved": false
      }
    ]
  }
}
```

### 복구 성공 시

```json
{
  "current_task": {
    "plan": {
      "steps": [
        {
          "id": 1,
          "status": "completed",
          "error": null,
          "retries": 3
        }
      ]
    },
    "issues": [
      {
        "step_id": 1,
        "type": "transient",
        "message": "API rate limit exceeded",
        "resolution": "retry",
        "resolved": true,
        "resolved_at": "2025-11-18T10:32:00Z"
      }
    ]
  }
}
```

---

## 재계획 트리거

### 자동 트리거
- 동일 단계 3회 연속 실패
- 예상 시간 2배 초과
- 치명적 오류 발생

### 수동 트리거
- 사용자 요청 변경
- 새로운 제약 조건 발생
- 더 좋은 접근 방식 발견

---

## 재계획 프로세스

### 1단계: 상태 스냅샷
```markdown
## 재계획 전 상태

### 완료된 단계
- [단계 1]: [결과 요약]
- [단계 2]: [결과 요약]

### 실패한 단계
- [단계 3]: [실패 원인]

### 중간 산출물
- [산출물 1]: [경로]

### 활용 가능 정보
- [정보 1]
```

### 2단계: 원인 분석
```markdown
## 실패 원인 분석

### 근본 원인
[원인 설명]

### 영향 범위
[영향 받는 단계]

### 제약 조건
[새로 발견된 제약]
```

### 3단계: 대안 평가
```markdown
## 대안 평가

### 대안 1
- 설명: [...]
- 장점: [...]
- 단점: [...]
- 실현 가능성: [높음/중간/낮음]

### 대안 2
- 설명: [...]
- ...

### 선택
[선택한 대안]: [선택 이유]
```

### 4단계: 새 계획 수립
기존 계획 형식에 따라 새 계획 작성

### 5단계: 실행 재개
새 계획의 첫 미완료 단계부터 실행

---

## 에이전트별 복구 행동

### 모든 에이전트 공통

```markdown
## Recovery Behavior

### 실패 감지 시
1. 오류 로깅 (유형, 메시지, 컨텍스트)
2. 상태 저장 (현재까지 진행 상황)
3. 자체 복구 시도 (해당되는 경우)
4. 상위 에이전트/오케스트레이터에 보고

### 보고 형식
- 실패 유형
- 오류 메시지
- 컨텍스트
- 시도한 복구
- 필요한 조치

### 자체 복구 가능 범위
- 일시적 API 오류: 재시도
- 형식 오류: 자체 수정
- 경미한 검증 실패: 즉시 재작성
```

---

## 예시: 블로그 포스트 작성 실패 복구

### 시나리오
web-researcher가 API rate limit으로 실패

### 복구 과정

1. **감지**: web-researcher가 429 오류 반환
2. **분류**: Transient Failure
3. **1차 시도**: 2초 대기 후 재시도 → 실패
4. **2차 시도**: 4초 대기 후 재시도 → 실패
5. **3차 시도**: 8초 대기 후 재시도 → 성공
6. **상태 업데이트**: retries: 3, status: completed

### 만약 3차도 실패했다면

1. **재계획 트리거**: 3회 연속 실패
2. **대안 평가**:
   - Context7 MCP 사용
   - 캐시된 정보 활용
   - 범위 축소
3. **새 계획**: Context7 MCP로 공식 문서 조회
4. **실행 재개**: 새 계획으로 진행

---

## 복구 품질 지표

### 추적 지표
- 총 실패 횟수
- 실패 유형별 분포
- 평균 복구 시간
- 재계획 비율
- 에스컬레이션 비율

### 목표 지표
- 자동 복구율: > 90%
- 평균 복구 시간: < 30초
- 재계획 성공률: > 80%

---

## 베스트 프랙티스

### DO
- 실패 즉시 상태 저장
- 적절한 실패 유형 분류
- 지수 백오프 적용
- 중간 결과 보존
- 상세한 실패 로깅

### DON'T
- 무한 재시도
- 실패 무시
- 상태 저장 없이 재시도
- 중간 결과 폐기
- 원인 분석 없이 재계획

---

## 관련 문서

- [planning-protocol.md](./planning-protocol.md): 계획 프로토콜
- [state-management.md](./state-management.md): 상태 관리
- [orchestrator.md](../agents/orchestrator.md): 오케스트레이터 에이전트
