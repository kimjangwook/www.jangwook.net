# Deep Agents 연구 조사

## 연구 일자
2025-11-18

## 참고 자료
- [LangChain Blog: Deep Agents](https://blog.langchain.com/deep-agents/)
- [Philipp Schmid: Agents 2.0 - Deep Agents](https://www.philschmid.de/agents-2.0-deep-agents)

---

## 1. Deep Agents 정의

### Shallow Agents (Agent 1.0)
- **구조**: 단순한 while 루프 (입력 → LLM → 도구 호출 → 반복)
- **특성**: 반응적(reactive), 무상태(stateless), 일시적(ephemeral)
- **한계**: 5〜15단계 작업에 적합, 500단계 작업에서 실패
- **실패 원인**: 컨텍스트 윈도우 제한, 목표 이탈(goal drift)

### Deep Agents (Agent 2.0)
- **구조**: 사전 계획 + 영구 외부 메모리 + 계층적 작업 위임
- **특성**: 능동적(proactive), 상태 유지, 장기 실행 가능
- **장점**: 시간 단위 또는 일 단위의 복잡한 문제 해결
- **예시**: Claude Code, Deep Research, Manus

---

## 2. Deep Agents의 4가지 핵심 원칙

### Pillar 1: Explicit Planning (명시적 계획)
- **기존**: 암묵적 Chain-of-Thought 추론
- **개선**: 편집 가능한 계획 문서(주로 마크다운) 유지
- **구현**:
  - 단계별 상태 관리 (pending, in_progress, completed)
  - 실패 시 계획 업데이트 (맹목적 재시도 대신)
  - 실행 사이클 간 계획 검토 및 수정
- **예시**: Claude Code의 Todo list (no-op 도구지만 컨텍스트 엔지니어링 전략으로 효과적)

### Pillar 2: Hierarchical Delegation (계층적 위임)
- **패턴**: Orchestrator + Specialized Sub-agents
- **역할 분리**:
  - Orchestrator: 고수준 목표 관리, 작업 분배
  - Sub-agents: 전문 도메인 작업 수행 (researcher, coder, writer 등)
- **장점**:
  - 각 에이전트가 깨끗한 컨텍스트로 작업
  - 최종 합성 결과만 상위로 전달
  - 컨텍스트 오염 방지
- **핵심**: 서브에이전트는 자체 도구 루프 수행 후 요약만 반환

### Pillar 3: Persistent Memory (영구 메모리)
- **문제**: 전통적 에이전트는 대화 기록에만 상태 저장
  - 도구 출력(HTML, 복잡한 데이터)이 지침을 밀어냄
  - 컨텍스트 오버플로우 발생
- **해결**: 외부 저장소로 상태를 컨텍스트 윈도우에서 분리
  - 파일 시스템, 벡터 데이터베이스 등
  - 중간 출력을 저장, 후속 에이전트가 필요한 정보만 참조
- **패러다임 전환**: "모든 것을 기억" → "정보를 어디서 찾을지 아는 것"

### Pillar 4: Extreme Context Engineering (극한의 컨텍스트 엔지니어링)
- **특성**: 수천 토큰 길이의 상세한 지침
- **내용**:
  - 계획을 위한 명시적 중단점
  - 서브에이전트 생성 프로토콜
  - 도구 사용 예제 (few-shot)
  - 파일 구조 표준
  - 인간 협업 형식
  - 에지 케이스 처리
  - 의사결정 프로토콜
- **예시**: Claude Code의 재구성된 시스템 프롬프트는 "길고 상세한 도구 사용 지침과 행동 few-shot 포함"

---

## 3. 구현 전략

### deepagents 패키지 (LangChain)
일반화된 프레임워크 제공:
- 커스터마이징 가능한 시스템 프롬프트
- No-op 계획 도구
- 서브에이전트 생성 기능
- 에이전트 상태를 활용한 가상 파일 시스템

### 핵심 구현 요소

1. **상세한 시스템 프롬프트**
   - 최소한의 지침 대신 포괄적인 시스템 프롬프트에 투자
   - 도구 사용법, 행동 예시, 에지 케이스 처리 포함

2. **계획 도구**
   - 명시적 계획 단계 구현
   - 계획 검토 및 업데이트 메커니즘

3. **서브에이전트**
   - 작업 분해를 통한 컨텍스트 관리
   - 프롬프트 단축 및 전문화 가능

4. **파일 시스템 접근**
   - 작업 실행과 "메모리" 관리를 위한 영구 저장소
   - 축적된 컨텍스트 처리에 필수

---

## 4. Best Practices

### 구현 권장사항
- 최소한의 지침보다 포괄적인 시스템 프롬프트에 투자
- 명시적 계획 단계 구현
- 서브에이전트를 통한 작업 분해 활성화
- 컨텍스트 관리를 위한 영구 저장소 제공
- 수직적(vertical) 사용 사례에 맞게 컴포넌트 커스터마이징

### 복구 메커니즘
- 서브 작업 실패 시 복구 방법 정의
- 계획 실패 시 전략적 재계획 (맹목적 재시도 대신)

### 인간-인-더-루프
- 엄격한 포맷팅 요구사항으로 협업 구조화
- 명확한 중단점에서 인간 검토 요청

---

## 5. Shallow vs Deep Agents 비교

| 측면 | Shallow (1.0) | Deep (2.0) |
|------|---------------|------------|
| **계획** | 암묵적 CoT | 명시적 문서화된 계획 |
| **상태** | 대화 기록 | 외부 영구 저장소 |
| **구조** | 평면적 루프 | 계층적 오케스트레이션 |
| **프롬프트** | 최소한 | 수천 토큰, 상세 지침 |
| **복잡성** | 5-15단계 | 500+ 단계 |
| **실행 시간** | 초 단위 | 시간/일 단위 |
| **실패 처리** | 재시도 | 재계획 |

---

## 6. 주요 인사이트

### 컨텍스트 엔지니어링의 중요성
- Deep Agents의 성공은 "컨텍스트 엔지니어링 전략"에 크게 의존
- 단순한 프롬프트가 아닌 체계적인 지침 설계 필요

### 파일 시스템 = 메모리
- 파일 시스템을 단순 I/O가 아닌 "메모리"로 활용
- 중간 결과, 상태, 계획을 저장하여 컨텍스트 윈도우 부담 경감

### 서브에이전트의 독립성
- 서브에이전트는 자체 도구 루프 수행
- 상위 에이전트에게는 합성된 결과만 전달
- 컨텍스트 오염 방지 및 고수준 목표 집중 가능

### 계획의 동적 특성
- 계획은 고정된 것이 아니라 실행 중 계속 업데이트
- 실패는 재시도가 아닌 재계획의 트리거

---

## 7. Claude Code 관련 시사점

### 이미 적용된 요소
- 상세한 시스템 프롬프트
- TodoWrite 도구 (계획 추적)
- 파일 시스템 접근 (영구 저장소)
- 서브에이전트 패턴 (Task 도구)

### 추가 적용 가능 영역
- 명시적 계획 문서화 메커니즘
- 계층적 오케스트레이션 강화
- 상태 관리 체계화
- 복구 및 재계획 프로토콜
